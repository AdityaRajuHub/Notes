Serialization
--------------

Converting Object state into persistent state
The class must implement Serializable interface
fileName.ser
File saved in binary format using ObjectOutputStream.writeObject(Object obj)

DeSerialization
---------------

Converting file to object

ObjectInputStream.readObject()

---------------------------------------------------

Volatile
--------

If avariable is declared as volatile then that variable will be visible to all the threads running on different cores having separate cache.


---------------------------------------------------

JVM
---

Responsible for converting java file to bytecode and then bytecode is sent as Native OS method calls.

Consists of

1. Class Loader - (Load app's .class files)

2. Execution engine - execute byte code

Class Loading subsystem consists of 3 phases

1. Load
	a. Application class loader (classpath, -cp)
	b. Extension class loader (load files from jre/lib/ext)
	c. Bootstrap class loader (load class files from app)

2. Link
	a. Verify  (Verify bytecode is valid)
	b. Prepare (Class variables to default values)
	c. Resolve (Symbolic linking)

3. Initialize (Static block is executed and memory allocated)

ClassNotFoundException occurs during Loading phase
NoClassDefFoundError   occurs during Linking phase
-------------------------------------------------------

Execution engine
-----------------
1. Interpreter - looks at bytecode and interprets which OS native method to invoke
2. JIT
3. Hotspot profiler
4. GC

----------------------------------------------------

Java Memory Model
-----------------

ALl the memory allocations reside in JVM

1. Heap space 			- Dynamic memory 	- Objects
2. PermGen space(Method area)	- Static memory	 	- Loaded Classes, Static (variables, methods)	- OutofMemoryError based on MaxPermsize allocated
   Java 8- Metaspace 		- Physical memory	- Memory allocated in RAM, managed by OS  	- OutofMemoryError doesn't happen
3. Stack(1 stack/thread)	- Stack memory	 	- function calls, function variables		- StackOverflowError
4. Native method stack		- Native Stack memory	- OS native method calls (.dll)			- StackOverflowError
5. PC registers(1/stack)	- Cache memory	 	- holds the current instruction address in the stack

Heap space is again divided into 
1. Young generation space
2. Old generation space

Young generation is where new Objects arrive. Internally has 3 divisions based on how much time an object is live and being referenced inside the program, 
1. EdenSpace
2. FromSpace (Survivor1)
3. ToSpace (Survivor2)
4. Old Generation - most live objects

Finally it moves to Old generation where it is most likely to be used in the future as well.

Memory specifications:
----------------------

Heap: 	-Xmx -Xms
PermGen:-XX:PermSize -XX:MaxPermSize
Stack: 	-Xss


Garbage collection strategy
---------------------------
1. Marking
2. Deletion
3. Deletion + Compacting