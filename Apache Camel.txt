
What is Apache Camel?
---------------------

Apache Camel is a powerful open source integration framework based on known Enterprise Integration patterns.
Transfer messages between two different types of technologies.

Ex: Source File to Destination File, JDBC to Java, Java to ActiveMQ etc.

Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions by Gregor Hohpe and Bobby Woolf. 
It is common for people to refer to this book by its initials EIP. As the subtitle of EIP suggests, 
	the book focuses on design patterns for asynchronous messaging systems. 
The book discusses 65 patterns. 
Each pattern is given a textual name and most are also given a graphical symbol, intended to be used in architectural diagrams.

***Camel lets you design and implement solutions to integration problems using enterprise integration patterns (EIPs).

One of the fundamental principles of Camel is that the data could be in any format, a developer need not convert it to canonical form.

Provides 3 major tasks
----------------------

1. Intelligent Routing
2. Message Transformation
3. Protocol Mediation

It is a mini ESB Enterprise Service Bus

Why to use?
-----------

If we have a Legacy application (devloped in old technology) and some new application exchanging data say XML -> JSON we need to perform
marshalling & unmarshalling and if suddenly one day Legacy changed the implementation then the new tech will be impacted.
So in order to remove this tight coupling we can maintain additional layer to mitigate the difference between the applications.
This helps in loose coupling.

Integration can be messy 
	- Different protocols and data formats. (support for more than 280 protocols and data types)

Framework hides all complexity so you can focus on business logic.

AUTOMATIC TYPE CONVERTERS >350	
	- Accept data in most data types and convert the data to a type they’re capable of using.

EXTENSIVE COMPONENT LIBRARY 
	- (library of more than 280 components)

Easy to integrate with Spring

Built in support for open source api's like activeMQ etc

Very less boiler plate code

Lightweight core ideal for Microservices
	- about 4.9 MB and having only 1.3 MB of runtime dependencies
	- easy to embed or deploy anywhere wherever you use Java 
		like standalone application, microservice, web application, Spring application,
		Java EE application, OSGi, Spring Boot, WildFly, and in cloud platforms such
		as AWS, Kubernetes, and Cloud Foundry. 


Camel Architecture
------------------
At a high level, Camel is composed of routes, processors, and components. 
All of these are contained within CamelContext.

		 ___________________________________________			 _______________________________________________________________
		|Camel Integration Engine and Router		|			| 						Camel Processors 						|
		|-----------------------------------		| 			| 						|- Wire endpoints together				|
		|Camel Endpoints							|<-------->	| Filter processor		|- Routing			 					|
		|	|- Camel can send messages to them	 	|<--------> | Router processor		|- Transformation				 		|
		|	|- can receive messages from them	 	|			|						|- Mediation				 		    |
		|____|___________|___________|______________|			|						|- Interception, Enrichment, Validation,|
			 |			 |			 |							|__________________________Tracking, Logging____________________|	
			 |			 |			 |												
Endpoints:	JMS 		Http		File	........
			Component   Component	Component
			|- JMS API	|- ServletAPI	|- File system			Camel Component
																	|- Provide uniform endpoint interface				
			JMS Providers: ActiveMQ, Tibco, Sonic ...				|- Acts as connectors to all other systems
			Webcontainer: Jetty, Tomcat ...
			Http Client: Chrome, Mozilla ...
			
[ DB, Files, Queue, Http ]	----------------------> Transformation --> Processing	-----------------> 	[ DB, Files, Queue, Http ]
			

At the core of the Camel framework is a routing engine, or more precisely a routing-engine builder. 

It allows you to define your own routing rules, decide from which sources to accept messages, 
	and determine how to process and send those messages to other destinations. 
Camel uses an integration language that allows you to define complex routing rules, akin to business processes.

Camel has two main ways of defining routing rules: 
	1. Java-based domain specific language (DSL) and 
	2. XML configuration format.

Components
----------
Components are the extension points in Camel for adding connectivity to other systems.
To expose these systems to the rest of Camel, components provide an endpoint interface.

They’re associated with a name that’s used in a URI, and they act as a factory of endpoints.
Ex: FileComponent is referred to by file in a URI and it create FileEndpoints.

Systems: AWS, MongoDB, ActiveMQ, Twitter, FILE, JDBC, JMS, SFTP, Streams, SQL, UDP, Cache, Websockets,
		 SMTP, SSH, SOLR, RMI, Velocity, XSLT, TCP etc...

Ex: 
	ConnectionFactory connectionFactory= new ActiveMQConnectionFactory();
	camelContext.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));

Endpoint
--------

It is a camel abstraction that models the end of a channel through which system sends/receives messages.
Configure endpoints using URI like below

		file:data/inbox?delay=5000
		  ❶	 ❷			❸
1. Scheme	
2. Context path 
3. Options

The scheme ❶ denotes which Camel component handles that type of endpoint. 
In this case, the scheme of file selects FileComponent.
FileComponent then works as a factory, creating FileEndpoint based on the
	remaining parts of the URI. 

The context path data/inbox ❷ tells FileComponent that the starting folder is data/inbox. 

The option, delay=5000 ❸ indicates that files should be polled at a 5-second interval.

An endpoint acts as a factory which produces Producer and Consumer which interact by sending/receiving messages to/from an endpoint.

			
				creates
Component --------> Endpoint ----------> Consumer calls Processors
						|	|----------> Producer	
						|	
					Creates Exchange

Consumer					
--------

Consumer is the service that receives messages from an external system (say file system), wraps them in an exchange
	and sends them for processing. Think "from" in DSL.
	
	2 types Event driven and Polling consumer
	
	Event Driven -> Asynchronous receiver
					Client-server architectures and web services.
					Ex: Listens on messaging channel, such as a TCP/IP port, JMS queue, 
						Twitter handle, Amazon SQS queue, WebSocket, and so on
	
	Polling		 -> Synchronous receiver
					Polls at scheduled intervals. 
					Example Components: File, FTP, and email
					
Processors
----------
Used to perform operation on the source before it is sent to another processor or MEP or to destination endpoint.
The output from one processor can be input to another processor and so on.
				out			in				out			in									InOnly
	Consumer-----------------> Processor ---------------> Processor ---------------> MEP----------->
		|																			  |
		|_____________________________________________________________________________|InOut


***MEP - Message Exchange Pattern
Consumer is the originator of the request. It is "from" in DSL.

1. At each processor step, the out message from the previous step is the in message of the next. 
2. In many cases, processors don’t set an out message, so in this case the in message is reused. 
3. At the end of a route, the MEP of the exchange determines whether a reply needs to be sent
	back to the caller of the route. 
4. If the MEP is InOnly, no reply will be sent back. 
5. If it’s InOut, Camel will take the out message from the last step and return it. 

The processor class must implement org.apache.camel.Processor interface and implements below one method

	public void process(Exchange exchange) throws Exception;

Camel Routes
------------

1. Routes are crucial part of Camel
2. Route is an ordered combination of processing steps.
3. Each route in Camel has a unique identifier that’s used for logging,
	debugging, monitoring, and starting and stopping routes.
	
4. Routes also have exactly one input source for messages, 
	so they’re effectively tied to an input endpoint.

Although we can mention multiple input sources to a route but internally it is split into multiple routes.

Syntax:
-------
from("jms:queue:A", "jms:queue:B", "jms:queue:C").to("jms:queue:D");

Under the hood:
---------------
from("jms:queue:A").to("jms:queue:D");
from("jms:queue:B").to("jms:queue:D");
from("jms:queue:C").to("jms:queue:D");


DOMAIN-SPECIFIC LANGUAGE (DSL)
------------------------

The purpose of the DSL is to allow the developer to focus on the integration problem rather than 
on the tool—the programming language.

	Java DSL 
	--------
	
	from("file:target/inbox")
	
	.process(new LoggingProcessor())					-> Process, before Tranforming ex: logging
	
	.bean(new TransformationBean(), "makeUpperCase") 	-> Tranform, call makeUpperCase() method in the passed instance passing the file content as input param
	
	.to("file:target/outbox/dvd");

	XML DSL for Spring
	-------
	
	<route>
		<from uri="file:target/inbox"/>
		<process ref="loggingProcessor"/>
		<bean ref="transformationBean"/>
		<to uri="file:target/outbox/dvd"/>
	</route>


Filters
-------

Used to filter the source which satisfies some criteria & send to target

1. move file only if filename is of certain type 		-> 	from("file:inbox").filter(header(Exchange.FILE_NAME).endsWith(".txt")).to("file:outbox")

2. move file only if the content contains some string	->	from("file:inbox").filter(body().contains("Java")).to("file:outbox")

3. convert txt file to csv file	

4. scan recursively in a subfolder and include only .txt files -> from("file:data/inbox?recursive=true&include=.*txt$")

Message Model
-------------

Camel uses two abstractions for modeling messages

1. org.apache.camel.Message 
	The fundamental entity containing the data being carried and routed in Camel.

2. org.apache.camel.Exchange 
	The Camel abstraction for an exchange of messages. This exchange of messages has an in message, 
	and as a reply, an out message.

Messages are entities used by systems to communicate with each other using messaging channels.
Messages flow in one direction from sender to receiver.

Message (unique ID)
	|- Headers				(sender identifiers, hints about content encoding, authentication information, and so on.)
	|- Attachments 			(optional, typically for webservice and email components)
	|- Body 				(a Payload of type java.lang.Object)
								When the sender and receiver use different Body formats, Camel provides mechanisms to
								transform the data into an acceptable format, and in those cases the
								conversion happens automatically with type converters, behind the scenes.

	During routing, messages are contained in an exchange.
	
									Exchange
		 ______________________________|____________________________________________
		|				|			|				|				|				|	
	Exchange ID		Exception	Properties	 	   MEP		In Message		OutMessage
											(InOnly/InOut)			|- Headers		|- Headers
																	|- Attachments	|- Attachments
																	|- Body			|- Body
		
	MEP -> Message Exchange Pattern
			used to differenciate between one-way or request-response messaging styles.
			InOnly -> JMS messaging
			InOut  -> Http based Client Server transports
	
	Exception
		If an error occurs at any time during routing, an Exception will be set in the exception field.
	
	Properties 
		Similar to message headers, but they last for the duration of the entire exchange. 
			Properties are used to contain global-level information, whereas message headers are specific to a particular message. 
			Camel itself adds various properties to the exchange during routing. You, as a developer,
			can store and retrieve properties at any point during the lifetime of an exchange.
			
	In message
			This is the input message, which is mandatory. 
			The in message contains the request message.

	Out message
			This is an optional message that exists only if the MEP is InOut. 
			The out message contains the reply message.

***The exchange is the same for the entire lifecycle of routing, but the messages
	can change, for instance, if messages are transformed from one format to another.
	
																
Enterprise Integration Patterns
-------------------------------
1. Splitter
2. Aggregator
3. Load Balancer
4. Dynamic Router
5. Routing Slip
			
		
					
Dependencies
------------

camel-core	-> contains camel context

camel-spring -> integration with spring

camel-jdbc -> integration with JDBC

camel-jms

activemq-all
activemq-camel -> Active MQ

camel-ftp

--------------------------------------------------------------------------------------------------

Listing 1.1 Routing files from one folder to another in plain Java

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class FileCopier {
	public static void main(String args[]) throws Exception {
			File inboxDirectory = new File("data/inbox");
			File outboxDirectory = new File("data/outbox");
			outboxDirectory.mkdir();
			File[] files = inboxDirectory.listFiles();
			for (File source : files) {
				if (source.isFile()) {
					File dest = new File(
					outboxDirectory.getPath() + File.separator + source.getName());
					copyFile(source, dest);
				}
			}
	}
	private static void copyFile(File source, File dest) throws IOException {
		OutputStream out = new FileOutputStream(dest);
		byte[] buffer = new byte[(int) source.length()];
		FileInputStream in = new FileInputStream(source);
		in.read(buffer);
		try {
			out.write(buffer);
		} finally {
			out.close();
			in.close();
		}
	}
}

Listing 1.2 Routing files from one folder to another with Apache Camel

import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;

public class FileCopierWithCamel {

	public static void main(String args[]) throws Exception {
		CamelContext context = new DefaultCamelContext();
		context.addRoutes(new RouteBuilder() {
		public void configure() {
			from("file:data/inbox?noop=true") 	//noop tell camel to leave the source file as is.
			//Routes files from inbox to outbox
			.to("file:data/outbox");
			}
		});
		context.start();
		Thread.sleep(10000);	//allow Camel application time to copy the files.
		context.stop();
	}
}


Camel Context
-------------

Camel's Runtime system.
Is a container of sorts.

Each camel context contains several services below

1. Components
	All components are loaded on the fly either by autodiscovery or when a new bundle is activated in OSGi container

2. Endpoints 
	Contains all the endpoints that have been used
	
3. Routes
	Camel Context contains mutiple RouteBuilder's which in turn contains multiple routes.
	
4. Type converters

5. Data formatters

6. Registry
	contains registry to lookup beans
	
7. Languages
	Ex: XPath


Routes
------

1. Download orders from ftp server and consume them

ftp://rider.com/orders?username=rider&password=secret

OR

ftp://rider:secret@rider.com/orders

Camel first looks up the ftp scheme in the component registry, which resolves to FtpComponent. 

FtpComponent then works as a factory, creating FtpEndpoint based on the remaining context path and options.

The context path of rider.com/orders tells FtpComponent that it should log
into the FTP server at rider.com on the default FTP port and change the directory to orders. 

Finally, the only options specified are username and password, which are used to log in to the FTP server.


from("ftp://rider.com/orders?username=rider&password=secret")

That’s all you need to do to consume files from an FTP server.


2. Send the orders you downloaded from the FTP server to a JMS queue.

What is JMS?
------------

Java API to create, send, receive and read messages.
It guarantees messaging is asynchronous and promises reliability, guaranteed and only-once delivery.

The communication between producer and consumer happens through an intermediary - a JMS destination.

JMS destination could be a Queue or a Topic.

In a Queue each message has only one consumer, but in a Topic 
it is publish/subscribe scheme, whoever is subscribed to the Topic receives the message.

JMS provides a ConnectionFactory that clients can use to create a connection with a JMS provider.
JMS providers are referred to as Brokers because they manage the communication.
	Ex: ActiveMQ

	jms:queue:incomingOrders
	
	jms 			-> indicates we are using JMS component
	queue(default) 	-> send to a queue not a topic
	incomingOrders 	-> name of the queue



The addRoutes method of CamelContext accepts RoutesBuilder, not just RouteBuilder. 

The RoutesBuilder interface has a single method defined:

	void addRoutesToCamelContext(CamelContext context) throws Exception;

class RouteBuilder implements RoutesBuilder

	public class MyRouteBuilder extends RouteBuilder {
		public void configure() throws Exception {
			...
		}
	}
	CamelContext context = new DefaultCamelContext();
	context.addRoutes(new MyRouteBuilder());

OR

	CamelContext context = new DefaultCamelContext();
	context.addRoutes(new RouteBuilder() {
		public void configure() throws Exception {
			...
		}
	});

The from method returns a RouteDefinition object, on which you can invoke 
	various methods that implement EIPs and other messaging concepts.

Camel’s type-converter facility automatically converts FTP file type to the JMS message type.

import javax.jms.ConnectionFactory;
import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.jms.JmsComponent;
import org.apache.camel.impl.DefaultCamelContext;
public class FtpToJMSExample {

public static void main(String args[]) throws Exception {

	CamelContext context = new DefaultCamelContext();
	ConnectionFactory connectionFactory =
	new ActiveMQConnectionFactory("vm://localhost");
	context.addComponent("jms",
	JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));
	context.addRoutes(new RouteBuilder() {
		public void configure() {
			from("ftp://rider.com/orders" + "?username=rider&password=secret") 
			.to("jms:incomingOrders"); 
		}
	});
	context.start();
	Thread.sleep(10000);
	context.stop();
	}
}

Processor
---------

Get full access to the message exchange, letting you do pretty much whatever you want with the payload or headers.

	from("ftp://rider.com/orders?username=rider&password=secret")
	.process(new Processor() {
		public void process(Exchange exchange) throws Exception {
			System.out.println("We just downloaded: " + exchange.getIn().getHeader("CamelFileName"));
		}
	})
	.to("jms:incomingOrders");

This route will now print the filename of the order that was downloaded before sending it to the JMS queue.

FTP consumer is fed into the processor as input; the processor doesn’t modify the message payload or headers, 
so the exchange moves on to the JMS producer as input.

FTP consumer and JMS producer since FTP is consumed and Message is produced by Camel.

Integration with Spring
-----------------------

1. To load up CamelContext in Spring, you can do the following:

		<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
		http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://camel.apache.org/schema/spring
		http://camel.apache.org/schema/spring/camel-spring.xsd">
		
			<camelContext xmlns="http://camel.apache.org/schema/spring"/>
		
		</beans>
	
	This automatically starts SpringCamelContext, which is a subclass of
		DefaultCamelContext, which you used for the Java DSL.
		
	To take it a bit further u need to specify routes in the context.
	
		<bean id="ftpToJmsRoute" class="camelinaction.FtpToJMSRoute"/>

		<camelContext xmlns="http://camel.apache.org/schema/spring">
			<routeBuilder ref="ftpToJmsRoute"/>
		</camelContext>
		
		public class FtpToJMSRoute extends RouteBuilder {
			public void configure() {
				from("ftp://rider.com/orders?username=rider&password=secret")
				.to("jms:incomingOrders");
			}
		}
		
		Dynamic Routers loading using packageScan and contextScan
		-----------------------
		
		1. Load all route builders in the camelinaction.routes package, except for ones with Test in the class name
		
			<camelContext xmlns="http://camel.apache.org/schema/spring">
				<packageScan>
					<package>camelinaction.routes</package>
					<excludes>**.*Test*</excludes>
					<includes>**.*</includes>
				</packageScan>
			</camelContext>
			
		2. Load any Camel route builders that are marked with the @Component annotation
			
			<context:component-scan base-package="camelinaction.routes"/>
				<camelContext xmlns="http://camel.apache.org/schema/spring">
				<contextScan/>
			</camelContext>
			
		
2. To start JMS component in Spring

	ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost");
	CamelContext context = new DefaultCamelContext();
	context.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));

	<bean id="jms" class="org.apache.camel.component.jms.JmsComponent">
		<property name="connectionFactory">
			<bean class="org.apache.activemq.ActiveMQConnectionFactory">
				<property name="brokerURL" value="vm://localhost"/>
			</bean>
		</property>
	</bean>
	
	In this case, if you send to an endpoint such as "jms:incomingOrders", ->*********instead of id as jms we could give any name
	
	Camel will look up the jms bean, and if it’s of type org.apache.camel.Component, it will use that. 
	So you don’t have to manually add components to CamelContext.


3. Configuring multiple routes in XML DSL

	<camelContext xmlns="http://camel.apache.org/schema/spring">
		<route>
			<from uri="file:src/data?noop=true"/>
			<to uri="jms:incomingOrders"/>
		</route>
		<route>
			<from uri="jms:incomingOrders"/>
			<process ref="downloadLogger"/>
		</route>
	</camelContext>

4. Configuring multiple Components of same type
	The bean id defines what this component will be called. 
	Give the component a more meaningful name based on the use case.
	
	<bean id="activemq" class="org.apache.camel.component.jms.JmsComponent">
	...
	</bean>
	
	<bean id="wmq" class="org.apache.camel.component.jms.JmsComponent">
	...
	</bean>

	URI: activemq:myActiveMQQueue or wmq:myWebSphereQueue.

5. Splitting XML into multiple files
	
	a. Move components to multiple files
	
	jms-setup.xml
	-------------
		
		<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans.xsd">
		
			<bean id="jms" class="org.apache.camel.component.jms.JmsComponent">
				<property name="connectionFactory">
				<bean class="org.apache.activemq.ActiveMQConnectionFactory">
					<property name="brokerURL" value="vm://localhost" />
				</bean>
				</property>
			</bean>
		</beans>

	applicationContext.xml
	----------------------
	
		<import resource="jms-setup.xml"/>

	b. Move routes to multiple files
		
		The route tags could be defined in different xml and imported
	
		<camelContext xmlns="http://camel.apache.org/schema/spring">
			<routeContextRef ref="ftpToJms"/>
		</camelContext>
		

Dynamic URI's
-------------

We can use toD method to build dynamic URI's

	toD("jms:queue:${header.myDest}")		-> picks up at runtime the destination from the header property
												which can be set by preceding processors
	<toD uri="jms:queue:${header.myDest}"/>
	
USING PROPERTY PLACEHOLDERS
---------------------------

Values will be replaced when Camel starts up, not on every new message, as in the case of toD.

A common use case is testing. A Camel route is often tested in different environments.
You don’t want to rewrite tests every time you move to a new environment.
That’s why you externalize dynamic parts rather than hardcoding them.


To ensure that the property placeholder is loaded and in use as early as
possible, you have to configure PropertiesComponent when CamelContext is
created:

	CamelContext context = new DefaultCamelContext();
	PropertiesComponent prop = camelContext.getComponent("properties", PropertiesComponent.class);
	prop.setLocation("classpath:rider-test.properties");
	
In the rider-test.properties file, you define the externalized properties as keyvalue pairs:

	myDest=incomingOrders

RouteBuilders can then take advantage of the externalized properties directly
in the endpoint URI, as shown in bold in this route:

	return new RouteBuilder() {
		@Override
		public void configure() throws Exception {
			from("file:src/data?noop=true")
			.to("jms:{{myDest}}");

			from("jms:incomingOrders")
			.to("mock:incomingOrders");
		}
	};
	
Using Spring property placeholder ${key} instead of {{key}}
---------------------------------
	
	<context:property-placeholder properties-ref="properties"/>
	<util:properties id="properties" location="classpath:rider-test.properties"/>
	<camelContext xmlns="http://camel.apache.org/schema/spring">
		<endpoint id="myDest" uri="jms:${myDest}"/>
		<route>
			<from uri="file:src/data?noop=true"/>
			<to uri="jms:${myDest}"/>	-> Not supported
			<to ref="myDest"/>			-> Supported
		</route>
		<route>
			<from uri="jms:incomingOrders"/>
			<to uri="mock:incomingOrders"/>
		</route>
	</camelContext>
		
Unfortunately, the Spring Framework doesn’t support using placeholders
directly in endpoint URIs in the route, so you must define endpoints that
include those placeholders by using the <endpoint> tag.
		
REFERENCING REGISTRY BEANS IN ENDPOINT URIS 	-> Use a #beanName inside the uri
----------------------------------------------

Fetch only CSV order files from the FTP site

	public class OrderFileFilter<T> implements GenericFileFilter<T> {
		public boolean accept(GenericFile<T> file) {
			return file.getFileName().endsWith("csv");
		}
	}
		
	registry.bind("myFilter", new OrderFileFilter<Object>());

Then you use the # syntax to refer to the named instance in the registry:

	from("ftp://rider.com/orders?username=rider&password=secret&filter=#myFilter")
		

--------------------------------------------------------------------------------------------

Routing and EIPs
-----------------

USING A CONTENT-BASED ROUTER
----------------------------

As the name suggests, Camel routes from source to dest based on its content.

Content can be

1. Message header
2. Payload data type
3. Payload content or anything in the message exchange

ex: 	if filename extension is .xml
			send to XMLOrders Queue
		else 
			send to CSVOrders Queue
			
	The choice method creates a CBR processor, and conditions are added by following 
	choice with a combination of a when method and a predicate.
		
		
	from("jms:incomingOrders")
	.choice()
	.when(predicate)
	.to("jms:xmlOrders")
	.when(predicate)
	.to("jms:csvOrders");
		
		
A predicate in Camel is a simple interface that has only a matches method:

	public interface Predicate {
		boolean matches(Exchange exchange);
	}		

Predicates are often built up from expressions, and expressions are used to extract a result 
	from an exchange based on the expression content. 
You can choose from many expression languages in Camel, some of which include 
	Simple, SpEL, JXPath, MVEL, OGNL, JavaScript, Groovy, XPath, and XQuery.

Within RouteBuilder, you can start by using the header method, which
	returns an expression that will evaluate to the header value.

	header("CamelFileName").endsWith(".xml")
	
	header maps to the headers of the in message of the exchange.

The complete DSL looks like 
------------------------------

	from("file:src/data?noop=true").to("jms:incomingOrders");
	from("jms:incomingOrders") 
	//Content-based router
	.choice() 
	.when(header("CamelFileName").endsWith(".xml")) 
	.to("jms:xmlOrders") 
	.when(header("CamelFileName").endsWith(".csv")) 
	.to("jms:csvOrders"); 
	
	from("jms:xmlOrders")
	//Test routes that print message content
	.log("Received XML order: ${header.CamelFileName}") 
	.to("mock:xml"); 
	
	from("jms:csvOrders") 
	.log("Received CSV order: ${header.CamelFileName}") 
	.to("mock:csv"); 
	
The Simple language
-------------------

Camel’s own expression language included with the camel-core module

${} placeholders

ex: ${header.CamelFileName}

	from("jms:incomingOrders")
	.choice()
	.when(simple("${header.CamelFileName} ends with 'xml'"))
	.to("jms:xmlOrders")
	.when(simple("${header.CamelFileName} ends with 'csv'"))
	.to("jms:csvOrders");

ends with is an operator


otherwise clause
----------------

	from("jms:incomingOrders")
	.choice()
	.when(header("CamelFileName").endsWith(".xml"))
	.to("jms:xmlOrders")
	.when(header("CamelFileName").regex("^.*(csv|csl)$"))
	.to("jms:csvOrders")
	.otherwise()
	.to("jms:badOrders");



Continue routing after a CBR ->	using end()
----------------------------

	from("jms:incomingOrders")
	.choice()
	.when(header("CamelFileName").endsWith(".xml"))
	.to("jms:xmlOrders")
	.when(header("CamelFileName").regex("^.*(csv|csl)$"))
	.to("jms:csvOrders")
	.otherwise()
	.to("jms:badOrders")
	.end()
	.to("jms:continuedProcessing");

Halt the route in CBR -> stop()
---------------------
	from("jms:incomingOrders")
	.choice()
	.when(header("CamelFileName").endsWith(".xml"))
	.to("jms:xmlOrders")
	.when(header("CamelFileName").regex("^.*(csv|csl)$"))
	.to("jms:csvOrders")
	.otherwise()
	.to("jms:badOrders").stop()
	.end()
	.to("jms:continuedProcessing");

	Any orders entering into the otherwise block will be sent only to the
		badOrders queue—not to the continuedProcessing queue.

Filtering based on Payload Content -> use XPath
----------------------------------

Filter out all the test orders from the real order arriving in the same queue
The test orders have an additional test attribute set in the order element.

XML payload
------------

	<?xml version="1.0" encoding="UTF-8"?>
	<order name="motor" amount="1" customer="foo" test="true"/>

	from("jms:xmlOrders")
	.filter(xpath("/order[not(@test)]"))
	.log("Received XML order: ${header.CamelFileName}")
	.to("mock:xml");

	The expression will evaluate to true for orders that don’t have the test attribute.

	XPath expressions are useful for creating conditions based on XML payloads.

Multicasting (sending to mutiple destinations)
----------------------------------------

	from("jms:xmlOrders")
	.multicast()
	.to("jms:accounting", "jms:production");

	By default, the multicast sends message copies sequentially. 
	In the preceding example, a message is sent to the accounting queue and then to the
	production queue means only a single thread is involved. 
	
	But what if you want to send them in parallel?


PARALLEL MULTICASTING
---------------------

This sets up the multicast to distribute messages to the destinations in parallel. 
Under the hood, a thread pool is used to manage threads.

	from("jms:xmlOrders")
	.multicast().parallelProcessing()
	.to("jms:accounting", "jms:production");


What if we want to issue orders to Accounting and Production simultaneously only for some?
-----------------------------------------------------------------------------------------

Camel provides a recipientList method for implementing the Recipient List EIP.

For example, the following route takes the list of recipients from a
	header named recipients, where each recipient is separated from the next by a comma:

	from("jms:xmlOrders").recipientList(header("recipients"));

This is useful if you already have some information in the message that can
	be used to construct the destination names—you could use an expression to create the list.
	
In order for the recipient list to extract meaningful endpoint URIs, the expression result must be iterable

	Ex: java.util.Collection, java.util.Iterator, java.util.Iterable, Java arrays,
		org.w3c.dom.NodeList, and a String with comma-separated values.

Other simple solution could be to call out to a custom Java bean to do this:

	from("jms:xmlOrders")
	.setHeader("recipients", method(RecipientsBean.class, "recipients"))
	.recipientList(header("recipients"));

	public class RecipientsBean {
		public String[] recipients(@XPath("/order/@customer") String customer) {	//-> map customer attribute 
			if (isGoldCustomer(customer)) {											//   of order element to this input string						
				return new String[]{"jms:accounting", "jms:production"};
			} else {
				return new String[]{"jms:accounting"};
			}
		}
		private boolean isGoldCustomer(String customer) {
			return customer.equals("honda");
		}
	}

USING THE WIRETAP METHOD
------------------------

Inspecting messages as they flow through a system is useful and necessary.
For instance, when an order fails, you need a way to look at which messages 
	were received to determine the cause of the failure.
	
You could use a simple processor, as you’ve done before, to output
	information about an incoming message to the console or append it to a file.

Here’s a processor that outputs the message body to the console:

	from("jms:incomingOrders")
	.process(new Processor() {
		public void process(Exchange exchange) throws Exception {
			System.out.println("Received order: " +
			exchange.getIn().getBody());
		}
	});
	
This is fine for debugging purposes, but it’s a poor solution for production
use. What if you wanted the message headers, exchange properties, or other
data in the message exchange? 

Ideally, you could copy the whole incoming exchange and send that to another channel for auditing. 

By using the wireTap method in the Java DSL, you can send a copy of the
	exchange to a secondary destination without affecting the behavior of the rest of the route:

	from("jms:incomingOrders")
	.wireTap("jms:orderAudit")	-> send a copy to orderAudit queue
	.choice()
	.when(header("CamelFileName").endsWith(".xml"))
	.to("jms:xmlOrders")
	.when(header("CamelFileName").regex("^.*(csv|csl)$"))
	.to("jms:csvOrders")
	.otherwise()
	.to("jms:badOrders");

The preceding code sends a copy of the exchange to the orderAudit queue,
and the original exchange continues on through the route, as if you hadn’t
used a wire tap at all. 

Camel doesn’t wait for a response from the wire tap
because the wire tap sets the message exchange pattern (MEP) to InOnly.
The message will be sent to the orderAudit queue in a fire-and-forget fashion
—it won’t wait for a reply.



--------------------------------------------------------------------------------------------------------

Data transformation overview
----------------------------

Transform from one form to another adapting to whatever protocol the receiver understands
so that sender and receiver can communicate. This is called mediation. 

Mediation and data transformation are key features in any integration kit, including Camel.

1. Data format transformation
		The data format of the message body is transformed from one form to another. 
		For example, a CSV record is formatted as XML.

2. Data type transformation—
		The data type of the message body is transformed from one type to another. 
		For example, java.lang.String is transformed into javax.jms.TextMessage.
		
In most cases, the data transformation you’ll face with Camel is format transformation: 
you have to mediate between two protocols.


USING THE MESSAGE TRANSLATOR EIP
--------------------------------

	Incoming message ----------> message translator ------------> Translated message
	
	
	This pattern covers translating a message from one format to another. 
	It’s the equivalent of the Adapter pattern from the Gang of Four book.

Camel provides three ways of using this pattern:

1. Using Processor
2. Using Java beans
3. Using <transform>

	TRANSFORMING USING PROCESSOR
	----------------------------

		from("quartz2://report?cron=0+0+6+*+*+?")
		
		.to("http://riders.com/orders/cmd=received&date=yesterday")
		
		.process( exchange -> {
			String custom = exchange.getIn().getBody(String.class); 
			
			//Gets custom payload
			String id = custom.substring(0, 10); 
			
			//Extracts data to local variables
			String customerId = custom.substring(10, 20); 
			String date = custom.substring(20, 30); 
			String items = custom.substring(30); 
			String[] itemIds = items.split("@"); 
			StringBuilder csv = new StringBuilder(); 
			
			//Maps to CSV format
			csv.append(id.trim()); 
			csv.append(",").append(date.trim()); 
			csv.append(",").append(customerId.trim()); 
			for (String item : itemIds) { 
			csv.append(",").append(item.trim()); 
			} 
			exchange.getIn().setBody(csv.toString());
			
		 })
		 
		.to("file://riders/orders?fileName=report-${header.Date}.csv");

		The preceding route uses Quartz to schedule a job to run once a day at 6 a.m.
		It then invokes the HTTP service to retrieve the orders received yesterday,
		which are returned in the custom format. Next, it uses OrderToCsvProcessor
		to map from the custom format to CSV format before writing the result to a
		file.

		getIn and getOut methods
		------------------------

		getIn()		->  method returns the incoming message, and the 
						A read-only scenario, such as when you’re logging the incoming message

		getOut()	->	method accesses the outbound message
						A write scenario, such as when you’re transforming the message

		when using getOut: the incoming message headers and attachments will be
		lost. So you must copy the headers and attachments from the incoming message to the outgoing message, 
		which can be tedious. The alternative is to set the changes directly on the
		incoming message by using getIn, and not to use getOut at all.

	TRANSFORMING USING BEANS
	------------------------
	
		The advantage is that Your bean is totally independent of the Camel API.
		Easy to unit test since we won't be needing exchange object.
		
		from("quartz2://report?cron=0+0+6+*+*+?")
		.to("http://riders.com/orders/cmd=received&date=yesterday")
		.bean(new OrderToCsvBean())
		.to("file://riders/orders?fileName=report-${header.Date}.csv");

		The method name could be anything but it’s a static method.
		
		The method signature defines the contract, which means that the first
		parameter (String custom) is the message body you’re going to use for
		translation. The method returns a string, which means the translated data
		will be a String type. At runtime, Camel binds to this method signature


	USING THE TRANSFORM METHOD
	--------------------------
		
		transform is a method in Camel which allows the use of expressions.
		
		from("direct:start")
		.transform(body().regexReplaceAll("\n", "<br/>"))
		.to("mock:result");
		
		Camel provides the Builder pattern to build compound expressions from individual expressions.
		This is done by chaining together method calls, which is the essence of the Builder pattern.

		The expression should be read as follows: take the body and perform a regular expression
		that replaces all new lines (\n) with <br/> tags.
		
		The Direct component
		--------------------
		
		The Direct component provides direct invocation between a producer and a consumer. 
		It allows connectivity only from within Camel, so external systems can’t send messages
		directly to it. 
		This component is used within Camel to do things such as link routes together or for testing.

		Custom expressions
		------------------
		
		from("direct:start")
		.transform(new Expression() {
			public <T> T evaluate(Exchange exchange, Class<T> type) {
				String body = exchange.getIn().getBody(String.class);
				body = body.replaceAll("\n", "<br/>");
				body = "<body>" + body + "</body>";
				return (T) body;
			}
		})
		.to("mock:result");

USING THE CONTENT ENRICHER EIP
------------------------------

A message is enriched with data obtained from another resource.

	Basic message 	-> 	Enricher	-> 	Enriched message
							| use
						Resource
						
						
	1. pollEnrich -> 	This method merges data retrieved from another source by using a consumer.

	2. enrich ->		This method merges data retrieved from another source by using a producer.

	Difference
	----------
	
	FileComponent can be used with both, but 
	
		1. using enrich will write the message content as a file 
					
		2. using pollEnrich will read the file as the source.
		
		1. enrich assumes you want to use an incoming Exchange as a parameter to an another service request. 
			for example, your incoming Exchange could be a userID, but you really need the entire User object, 
			so you could enrich it by passing the userID to a REST service that returns the User object 
			which becomes the Exchange, etc.

		2. pollEnrich assumes the incoming Exchange is a simple trigger that tell a PollingConsumer 
			to look for data and create an Exchange (ignoring the contents of the incoming Exchange). 
			For example, you could have a timer or other business process event that requires 
			picking up a file for processing, etc. 
			that said, the incoming Exchange data is NOT used to dynamically configure the PollingConsumer...
			only the URI is used for this.
					
	
	Camel uses the 
	
		org.apache.camel.processor.aggregate.AggregationStrategy interface 
	
	to merge the result from the source with the original message, as follows:
	
		Exchange aggregate(Exchange oldExchange, Exchange newExchange);	
				
			from("quartz2://report?cron=0+0+6+*+*+?")
			.to("http://riders.com/orders/cmd=received&date=yesterday")
			.process(new OrderToCsvProcessor())

			.pollEnrich("ftp://riders.com/orders/?username=rider&password=secret", new AggregationStrategy() { 
						//Uses pollEnrich to read FTP file
						public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
							if (newExchange == null) {
								return oldExchange;
							}
							String http = oldExchange.getIn() 

							Merges data using AggregationStrategy.getBody(String.class); 
							String ftp = newExchange.getIn() 
							.getBody(String.class); 
							String body = http + "\n" + ftp; 
							oldExchange.getIn().setBody(body); 
							return oldExchange;
						}
					})
			.to("file://riders/orders");

	PollEnrich uses a polling consumer to retrieve messages, and it offers three time-out modes:
	
	1. pollEnrich(timeout=-1)		Polls the message and waits until a message arrives. 
									This mode blocks until a message exists.
	
	2. pollEnrich(timeout = 0)		Immediately polls the message if any exists;
									otherwise, null is returned. It never waits for messages to arrive, so this
									mode never blocks. This is the default mode.
	
	3. pollEnrich(timeout>0)		Polls the message, and if no message exists, it waits
									for one, waiting at most until the time-out triggers. This mode potentially
									blocks.
									It’s a best practice to either use timeout = 0 or assign a time-out value when
									using pollEnrich to avoid waiting indefinitely if no message arrives
















































































