Atomicity - Either the whole transaction is completed or none is.
Consistency
Isolation- Concurrency control
Durability- make sure data is saved even in case of failures

DDL: Used to define DB schema
DML: Used to manipulate data
DCL: Data control language is used to deal with rights, permissions and other controls of DB
TCL: Transaction control language

Normalization
-------------
A -> B A functionally determines B
means A uniquely identifies B, that also means for every A, there is a unique B.

1 NF
----
Remove Multiple values for a single column

2 NF
----- 
Remove Partial dependancy

A FD (functional dependency) that holds in a relation is partial when removing one of the determining attributes gives a FD that holds in the relation. A FD that isnt partial is full.

Eg if {A,B} → {C} but also {A} → {C} then {C} is partially functionally dependent on {A,B}.
If C can be determined by A itself then take that relation to a new table.

A functional dependency X → Y is a full functional dependency if removal of any attribute A from X means that the dependency does not hold any more; that is, for any attribute A ε X, (X – {A}) does not functionally determine Y. A functional dependency X → Y is a partial dependency if some attribute A ε X can be removed from X and the dependency still holds; that is, for some A ε X, (X – {A}) → Y.

-- FUNDAMENTALS OF Database Systems SIXTH EDITION Ramez Elmasri & Navathe

Notice that whether a FD is full vs partial doesnt depend on CKs (candidate keys), let alone one CK that you might be calling the PK (primary key).

(The definition of 2NF involves full functional dependence of non-CK attributes on CKs but any FD that holds is either full or partial. And PKs dont matter to 2NF either.)

3 NF
----
Remove transitive dependency

If AB -> C  and C -> DE, where C is a non -prime attribute, then D and E would only repeat in this table un-necessarily.
Better to make F1(ABC) and F2(CDE).

BCNF
----
Divide into tables such that there is only One candidate key per table.

------------------------------------------------------------------------------------------------------------------------
Indexing:
---------
Primary Index is applied on a unique key and if unique key is the primary key then by default the records are sorted based on that.
-------------
Clustered vs NonClustered Index
-------------------------------
1. Generally Clustered index is applied on a non-unique column.
Ex: Index on dept_name in student table
2. The way the db records are stored is altered since records are sorted based on index column.
3. One clustered index per table

NonClustered
------------
1. It does not alter the table but it maintains a separate object within the table which is sorted and points back to the original table.
2. Table can have multiple indexes.
3. Slower than clustered index

Secondary Index
---------------
This indexing maintains a hierarchy of index tables to perform searching faster.
Generally searching in the index table is linear search. So to increase the speed of searching
we can go with multiple hierarchy of index tables like a tree where the root contains a single table. 

------------------------------------------------------------------------------------------------------------------------

Delete vs Truncate
------------------
DML - DDL
delete can be rolled back - Not possible
slower than truncate

row_number() 
------------

Assign a unique number based on column

Syntax: row_number() over (order by customer_name) as order_number

order_number	customer_name
1					A
2					A
3					B
4					C
5					D

partition
---------

Partitions the records into groups based on a column and within that group there will be unique row numbers

row_number() over (partition by vendor_name order by vendor_name) vendor_number

order_number	customer_name	vendor_number vendor_name
1					A				1			VA
2					A				2			VA
3					B				3			VA
4					C				1			VB
5					D				2			VB

rank()
------
provide a way to give rank (may not be unique) based on criteria

rank() over(order by customer_name) as customer_no

order_number	customer_name	customer_no
1					A				1
2					A				1
3					B				2
4					C				3
5					D				4

------------------------------------------------------------------------------------------------------------------------

Correlated Subquery
-------------------

An inner query referencing outer query is correlated query. For every record in the outer query, inner query is executed so many times.

Ex: Get the secong highest salary
---------------------------------

select * from Employee emp1
where 2 = (
	select count(1) from Employee emp2
		where emp2.salary >= emp1.salary
)

Triggers:
--------
Allow you to execute a batch of code upon insert, delete, update a specific table.
1. Before/After insert
2. Before/After update
3. Before/After delete


















