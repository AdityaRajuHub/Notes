Association
-----------
Association is relation between two separate classes which establishes through their Objects. 
Association can be one-to-one, one-to-many, many-to-one, many-to-many.
In Object-Oriented programming, an Object communicates to other Object to use functionality and services provided by that object.
 
Composition and Aggregation are the two forms of association.

In both aggregation and composition object of one class "owns" object of another class. 
But there is a subtle difference: . ... 


Aggregation
-----------
Aggregation implies a relationship where the child can exist independently of the parent
One class aggregating properties of another class by having a reference of other class as a property.
When the main class object reference is nullified, even then the aggregated reference is still valid.
It represents a Has-A relationship.
Employee Has-A Address(s)

ex: class Employee {
	private String name;
	private Address address;
	//setters, getters
}
//address reference can exist independantly even when employee reference points to null; is invoked.

Composition
-----------
Composition implies a relationship where the child cannot exist independent of the parent.
It is a stronger association.
It represents part-of relationship.
In composition, both the entities are dependent on each other.
Ex:
Engine is part-of Car, engine cannot exist separately.
House (parent) and Room (child). Rooms don't exist separate to a House.

public class Person {

    //composition has-a relationship
    private Job job;
   
    public Person(){
        this.job=new Job();
        job.setSalary(1000L);
    }
    public long getSalary() {
        return job.getSalary();
    }

}

Here job object has no meaning outside the Person class which means only when there is a Person do we need this job object.
Also without a person this job's variable salary cannot be set. 

When the job is not dependent on the person, ie. same salary for every person then the relation becomes aggregation,
and we can associate the job with the person. 

Also if there is any change in the other class implementation, for example getSalary returning String, we need to change Person class to accommodate it but client classes doesn’t need to change.

---------------------------------------------------------------

Serialization
--------------

Converting Object state into persistent state
The class must implement Serializable interface
fileName.ser
File saved in binary format using ObjectOutputStream.writeObject(Object obj)

DeSerialization
---------------

Converting file to object

ObjectInputStream.readObject()

---------------------------------------------------

Java Memory Model

			---------------------------
				Core1	|	Core2
			---------------------------
			RegisterA	|	RegisterB
			---------------------------
	flush()		CacheA	|	CacheB		refresh()
			---------------------------
					Shared Cache
			---------------------------
						RAM
			---------------------------
			
Maintaining the data for a thread in the cache is called Data Locality.
Whenever context switching happens the data for the thread is replaced by data with the scheduled thread.
For every thread in the JVM, there is an OS level thread allocated to run the OS level instructions.
The shared cache may not be updated immediately when the local cache is updated, so if two threads are operating on same data
	it creates a visbility problem. The updates by one thread may not be visible to other thread and vice versa.

Volatile
--------

If a variable is declared as volatile then that variable will be visible to all the threads running on different cores having separate cache.
Meaning that the variable will be immediately flushed from cacheA and cacheB will be refreshed so that the changes are reflected to other Thread.

Atomic
------
is like a indicator that the variable should be operated on atomically meaning by only one thread
ex: i++;

which internally is i=i+1 
Sequence of CPU instructions

1. Read i	(say 1)
2. Increment i	(1+1)
3. Write i		(2)

Thread 1	Thread2
-------------------
Read i
			Read i
Increment i
			Increment i
Write i
			Write i
			
Now the final output is 2 instead of 3 which is wrong. 
To avoid this we use AtomicInteger, Atomic Long variables for counters, 
which informs JVM to operate on the variable in a synchronized way.

---------------------------------------------------------------------------------------------------------

Making a class immutable
------------------------
1. Make the class final so that no class can extend that class
2. Make all the properties as private (making them final is optional if the properties are instantiated only inside constructor)
3. No setter methods
4. For the properties which reference mutable objects modify the getter such that 
	we are return the reference of the cloned object and not the original reference.
	
---------------------------------------------------------------------------------------------------------

Exception Handling
------------------

Throwable is the parent class of Java Exceptions Hierarchy and it has two child objects – Error and Exception
All of the methods are defined in the base class Throwable.
The exception classes are created to specify different kind of exception scenarios so that we can easily identify the root cause and handle the exception according to it’s type. 

Exceptions are further divided into checked exceptions and runtime exception.


Errors: Errors are exceptional scenarios that are out of scope of application and it’s not possible to anticipate and recover from them, for example hardware failure, JVM crash or out of memory error. That’s why we have a separate hierarchy of errors and we should not try to handle these situations. Some of the common Errors are OutOfMemoryError and StackOverflowError.

Checked Exceptions: Checked Exceptions are exceptional scenarios that we can anticipate in a program and try to recover from it, for example FileNotFoundException. We should catch this exception and provide useful message to user and log it properly for debugging purpose. Exception is the parent class of all Checked Exceptions and if we are throwing a checked exception, we must catch it in the same method or we have to propagate it to the caller using throws keyword.

Runtime Exception: Runtime Exceptions are cause by bad programming, for example trying to retrieve an element from the Array. We should check the length of array first before trying to retrieve the element otherwise it might throw ArrayIndexOutOfBoundException at runtime. RuntimeException is the parent class of all runtime exceptions. If we are throwing any runtime exception in a method, it’s not required to specify them in the method signature throws clause. Runtime exceptions can be avoided with better programming.

Java 7 improvements

try-with-resources
------------------

we can create a resource in the try statement itself and use it inside the try-catch block. 
When the execution comes out of try-catch block, runtime environment automatically close these resources. 
Sample of try-catch block with this improvement is:
ex 1: 
try (MyResource mr = new MyResource()) {
            System.out.println("MyResource created in try-with-resources");
        } catch (Exception e) {
            e.printStackTrace();
        }
ex 2:
public static void main(String[] args) {
	try (BufferedReader br = new BufferedReader(new FileReader(
			"C:\\journaldev.txt"))) {
		System.out.println(br.readLine());
	} catch (IOException e) {
		e.printStackTrace();
	}
}

We can open multiple resources in try-with-resources statement separated by a semicolon. For example, we can write following code:

try (BufferedReader br = new BufferedReader(new FileReader(
				"C:\\journaldev.txt"));
				java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(FileSystems.getDefault().getPath("C:\\journaldev.txt"), Charset.defaultCharset())) {
			System.out.println(br.readLine());
		} catch (IOException e) {
			e.printStackTrace();
		}
		
Java 7 has introduced a new interface java.lang.AutoCloseable. 
To use any resource in try-with-resources, it must implement AutoCloseable interface else java compiler will throw compilation error.
It has a close() which will be implemented in classes provided by Java.

try-catch-finally vs try-with-resources
---------------------------------------
If an exception is thrown in both try block and finally block, the method returns the exception thrown in finally block.

For try-with-resources, if an exception is thrown in a try block and in a try-with-resources statement, 
then the method returns the exception thrown in the try block.

Multiple exceptions in a single catch block
-------------------------------------------
catching multiple exceptions and they have similar code, then using this feature will reduce code duplication. 

catch(IOException | SQLException ex){
     logger.error(ex);
     throw new MyException(ex.getMessage());
}

Exception parameter (ex) is final, so you can’t change it

Best Practices
--------------
1. Use Specific Exceptions
such as IOException with further sub-classes as FileNotFoundException, EOFException etc.
makes debugging easy and helps client application to handle exceptions appropriately

2. Throw Early or Fail-Fast 
Instead of getting a null pointer exception we can have null check and throw appropriate exception like FileNameMandatoryException with appropriate message.

3. Catch Late
2 ways to deal with exceptions throw or catch. Catching the exception in some cases could be harmful.
It is better to throw exceptions to the caller and let caller handle the exception.
We should catch exception only when we can handle it appropriately.

4. Closing Resources in finally
5. Logging Exceptions
6. Single catch block for multiple exceptions using | symbol - This approach will reduce our code size and it will look cleaner too.
7. Custom Exceptions - define exception handling strategy at the design time, provide proper error code so that caller can handle easily
8. Document the Exceptions Thrown – Use javadoc @throws to clearly specify the exceptions thrown by the method, it’s very helpful when you are providing an interface to other applications to use.



-----------------------------------------------------------------------------------------------------

Custom annotation
-----------------

All annotations extends java.lang.annotation.Annotation interface. Annotations cannot include any extends caluse.

@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotationTest {
 
    String key();
    String value();
}
 
class MyAnnTest{
     
    @MyAnnotationTest(name = "test1", desc = "testing annotations")
    public void myAnnotationTestMethod(){
		try {
            Class<? extends MyAnnotationTest> cls = this.getClass();
            Method mth = cls.getMethod("myAnnotationTestMethod");
            MyAnnotation myAnno = mth.getAnnotation(MyAnnotation.class);
            System.out.println("key: "+myAnno.key());
            System.out.println("value: "+myAnno.value());
        } catch (SecurityException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}

A retention policy determines at what point annotation should be discarded.
Java defined 3 types of retention policies through java.lang.annotation.RetentionPolicy enumeration. It has SOURCE, CLASS and RUNTIME.
Annotation with retention policy SOURCE will be retained only with source code, and discarded during compile time.
Annotation with retention policy CLASS will be retained till compiling the code, and discarded during runtime.
Annotation with retention policy RUNTIME will be available to the JVM through runtime.
The retention policy will be specified by using java built-in annotation @Retention, and we have to pass the retention policy type.
The default retention policy type is CLASS.

single member annotation 
------------------------
Single member contatins only one member, and it is also kind of normal annotation.
The only difference we can make is the value assignment.
We can assign the value without specifing the member name as shown in the below example. This only works when we declare name of the member as value.


@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotn{
    String value();
}

@MyAnnotn("java2novice.com")
public void myAnnotationTestMethod(){
	 
	try {
		Class<? extends MySingleMembAnnotation> cls = this.getClass();
		Method mth = cls.getMethod("myAnnotationTestMethod");
		MyAnnotn myAnno = mth.getAnnotation(MyAnnotn.class);
		System.out.println("value: "+myAnno.value());
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}


------------------------------------------------------------------------------------










