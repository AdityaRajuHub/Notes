REST	- Roy Fielding	- Http sepcifications
----

Representational State Transfer: is transferring the state of a resource over the internet to the client.
		The state of a resource can be represented using XML/JSON format.

	So when a browser requests a server for data, server responds with a web page. 
	But what if an app requests data and it can't interpret a webpage
		in that case we need to transer state in the form of XML/JSON


SOAP 	- 	WSDL

REST	- 	No Service Definition
			No standards, rules
			Hence the name RESTful
			

	Let's duug HTTP
	
	What is HyperText?
	A.	Hyper Text is text which contains Hyper Links.
		HyperLinks are links to other text. ex: HTML which contains anchor tags linking to other pages

	(1) REST uses HTTP which uses Resource based URI's which contains Nouns not Verbs

		1. Addresses: 			invokes an action on server to do something
		
		2. Resource based URI: 	lookup a resource at a location
		
			Ex: Weather website
			
			Address: 	weatherapp.com/weatherLookup.do?zipcode=12345
			URI:		weatherapp.com/zipcode/12345
		
	(2) REST uses HTTP methods to lookup/alter a resource at a URI
	
		GET				/topics				Gets all topics 	- Idempotent
		GET				/topics/id			Gets the topic 		- Idempotent
		POST			/topics				Create new topic 	- Not Idempotent(creates mutiple resources)
		PUT				/topics/id			Update the topic 	- Idempotent
		DELETE			/topics/id			Delete the topic 	- Idempotent
	
		Idempotent		-	has the same effect even if invoked multiple times 		ex: count=100;
		Not Idempotent	- 	affects multiple resources if invoked multiple times	ex: count=count+1;
		
	****So Resource creation should be done by POST, the browser issues a warning if you are invoking the request again.
	
	(3) REST uses HTTP status codes to know about the status of the request
		
		1xx	-	Informational
		
		2xx	- 	Successful responses
				ex: 200 OK, 201 Created, 202 Accepted, 204 No content
		
		3xx	-	Redirection messages
				ex: 301 Moved Permanently, 304 Not modified
		
		4xx	-	Client error responses
				ex: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found
		
		5xx	-	Server error responses
				ex: 500 Internal Server Error, 502 Bad Gateway, 504 Gateway Timeout, 
		
		
	(4) REST uses HTTP Headers for knowing about the message 
		Headers contains Metadata.
	
		Http protocol 	1.1
		Http method		GET/POST/PUT/DELETE
		Content-Type:	text/xml, application/json
		Message Length
		Date		
		
	2 types of URI's
		
		1. Instance based URI			-	which means it returns a single instance of resource
		2. Collection Resource URI		-	which means it returns a collection of resource instances.
		
		
	1. Get all messages	-	Collection URI
	
		/messages
	
	2. Getting a message -	Instance URI	
	
		/messages/{messageId}
		
	3. Get all comments to a message -	Collection
		
		/messages/{messageId}/comments
	
		So /messages acts as a directory for all the comments for a message
		
		.../comments is a Collection URI 
	
	Filtering results	-	Query parameters
	-----------------
		
		/messages?offset=30&limit=10
		
		/messages?year=2014&offset=30&limit=10


	Http Methods
	------------
	
		We can have same URI's for multiple operations
		Using the right method we can perform the right operation
		
		/getProducts.do?id=10		->	GET /products/10
		
		/deleteProducts.do?id=10	->	DELETE /products/10
		
		
	REST response
	-------------
	JSON / XML
	
	The advantage of JSON over XML is that JSON can be easily converted to a webpage using JSON object for human consumption.


	HATEOAS
	-------
		Hypermedia as the Engine of Application State
		
		which means that hyper text is driving the client's interation with application.
		
		if user requests for a resource then the response could contain other resources uri's along with the actual resource.
		
		So the client developer need not hard code the uri's
		
		Request: 	GET	/api/messages/
		Response:
			[
				{
					"id": 10,
					"name": "REST API",
					"description": "Rest API by Roy Fielding",
					"href": "/messages/10"
					"likes-href"; "/api/messages/10/likes",
					"comments-href": "/api/messages/10/comments",
					"shares-href": "/api/messages/10/shares"
				},
				{
					"id": 20,
					"name": "Java",
					"description": "Java Black Book",
					"href": "/messages/20"
					"likes-href"; "/api/messages/20/likes",
					"comments-href": "/api/messages/20/comments",
					"shares-href": "/api/messages/20/shares"
				},
				{
					"id": 30,
					"name": "Javascript",
					"description": "Javascript is the future",
					"href": "/messages/30"
					"likes-href"; "/api/messages/30/likes",
					"comments-href": "/api/messages/30/comments",
					"shares-href": "/api/messages/30/shares"
				}
			]

		Observe that each resource in the collection consists of href property 
			which can be used to get that resource.
			
		This could be further improved by using "rel" attribute which is a HTTP attribute.

			[
				{
					"id": 10,
					"name": "REST API",
					"description": "Rest API by Roy Fielding",
					"links": [
								{
									"href": "/messages/10",
									"rel": "self"
								},
								{
									"href": "/api/messages/10/likes",
									"rel": "likes"
								},
								{
									"href": "/api/messages/10/comments",
									"rel": "comments"
								},
								{
									"href": "/api/messages/10/shares",
									"rel": "shares"
								}
							]
				}
			]

		With "rel" it is easy to find the resource that the client wants.

	Richardson Maturity Model
	---------------------------
	
		Tells us how well we have implemented RESTful WS
		
		1. Level 0	-	Swamp of POX (Plain Old XML)
							It is when the request XML contains operation name and parameters
							<create-request><id>10</id><name>Java</name></create-request>
							
		2. level 1	-	Resource URI
		
		3. Level 2	-	HTTP Methods + Resource URI
		
		4. Level 3	-	HATEOAS + HTTP Methods + Resource URI
		
	---------------------------------------------------------------------------------------------------
	
	Implementing REST API through JAX-RS (javax.ws.rs.*)
	---------------------
		
		JAX-RS is the specification which is implemented by many libraries like Jersey, RESTEasy etc.
		
		The specifications contains annotations and interfaces which the libraries implement,
			which means u can plugin any library u want and it will still work.
		
		Why Jersey?
		----------
			It is a reference implementation for JAX-RS.
			
		Maven archetype
		---------------
		Group Id:		org.glassfish.jersey.archetypes
		Artifact Id: 	jersey-quickstart-webapp
		Version:		2.14
		
		
	Annotations:
	-----------
	
	1. @Path									- 	class level and method level annotation
	
	2. @GET, @POST, @PUT, @DELETE				- 	place on method
	
	3. @Produces(MediaType.PLAIN_TEXT)			-	class and method level annotation
													signifies response content type
													JAXB does the conversion between Java POJO's and XML
													We need to add the dependency jars for converting JSON and Java POJo
													
	4. @Consumes(MediaType.APPLICATION_JSON)	-	class and method level annotation 
													signifies Request body content type
	
	4. @PathParam								- 	method level annotation for maping uri param with method parameters
		
		URI: /messages/1
		@Path("/messages/{messageId}")
		public List<message> getMessage(@PathParam("messageId") String msgId) {...}
		
	5. @QueryParam								-	method level annotation for mapping query parameters with method params
													Implement pagination using QueryParam
		URI: /messages?year=2014
		@Path("/messages")
		public List<message> getMessage(@QueryParam("year") int year) {...}
		
	6. @MatrixParam								-	method level annotation
		
		URI: /messages;year=2014
		
		Diff between @MatrixParam and @QueryParam
		-----------------------------------------
		The @MatrixParam annotation will apply to particular Resource present in URL and  @QueryParam will apply to whole Request URL.
			
			ex: /inventory/grocery;type=fruits/price;range=300/?limit=10 -	In this URI the params can be placed in between the uri
				First Matrix Param type=fruits is applying to only grocery resource same range=300 is applying to only price resource 
				but Query Param for pagination limit=10 is applying to whole Request URL. And yes, If only query parameters were used, 
				you would end up with parameters like "grocery_type" and "grocery_price" and you would lose the clarity added by the 
				locality of the parameters within the request.
		
		
		
	7. @HeaderParam 							-	extracts information from the HTTP headers. 
													can extract any custom header set in the HTTP Request Header.
	
	8. @CookieParam 							-	extracts information from the cookies declared in cookie related HTTP headers.
	
	9. @Context					 				-	to inject 12 object instances related to the context of HTTP requests.
													same as @Inject
													ex:
													public String getParamsUsingContext(@Context UriInfo uriInfo, @Context HttpHeaders headers) {...}
													
		The object instances that it can inject are the following:

			1. SecurityContext 		– Security context instance for the current HTTP request
			2. Request 				– Used for setting precondition request processing
			3. Application, Configuration, and Providers -> Provide access to the JAX-RS application, configuration, and providers instances
			4. ResourceContext 		– Resource context class instances
			5. ServletConfig 		– The ServletConfig instance instance
			6. ServletContext 		– The ServletContext instance
			7. HttpServletRequest 	– The HttpServletRequest instance for the current request
			8. HttpServletResponse 	– The HttpServletResponse instance for the current request
			9. HttpHeaders 			– Maintains the HTTP header keys and values
			10. UriInfo 			– Query parameters and path variables from the URI called
		
		
	10. @BeanParam								-	used when there are lot of annotated method parameters then u can move them to a POJO
													and create a parameter of POJO as method argument.
													public String getMessages(@BeanParam MessageFilterBean filterBean) {...}
													public class MessageFilterBean{
														@QueryParam private int year;
														@QueryParam private int initial;
														@QueryParam private int size;
														//setters and getters
													}
	
	SubResources
	------------
		A resource within a resource is a subresource.
			ex: comments, likes, shares within a message.
		
		We don't want to have subresources in the main resource itself.
		You have to delegate the request to a subresource.
		The path for the subresource is going to be the remainder path of uri left over by parent resource before
			delegating to the subresource.
		Subresource can access the parent resource Path parameters as well.
		
		Ex: /messages/3/comments
		
			@Path("/messages")
			class MessageResource {
				
				...
				
				@Path("{messageId}/comments")
				public CommentResource getCommentResource() {
					return new CommentResource();
				}
			}
			
			@Path("/")
			class CommentResource {
				
				@GET
				public List<Comment> getComments(@PathParam("messageId") long msgId) {
					...
				}
				
				@GET
				@Path("/{commentId}")
				public List<Comment> getComments(@PathParam("messageId") long msgId, @PathParam("commentId") long cmtId) {
					...
				}
	
			}
	
	Setting Response status codes
	-----------------------------
	
	To return a status code of 201 Created for new resource creation, and returning the resource in body.
		
		Response.status(Status.CREATED)
				.entity(newResource)
				.build();
	
	To return the above and URI for new resource
	
		Response.created(URI uri)	-> URI can be constructed using hardcoding new URI("/resources/"+newResource.getId())
				.entity(newResource)
				.build();
		
		Instead of hardcoding the URI we can also get path from URIInfo of Context and then append new Id.
		
			uriInfo.getAbsolutePathBuilder().path(newResource.getId()).build();
				
	
	Handling Exceptions
	-------------------
		1. To handle DataNotFoundException thrown in our code we need to implement below Mapper to send response 
			instead of Tomcat generated Error Response Html
		
			@Provider		-> register the below class with JAX-RS
			public class DataNotFoundExceptionMapper implements ExceptionMapper<DataNotFoundException> {
			
				@Override
				public Response toResponse(DataNotFoundException ex) {
				
					return Response.status(Status.NOT_FOUND)
									.entity(new ErrorMessage(ex.getMessage(), 404, "link to documentation"))
									.build();
				}
			}	
	
		2. To Handle any Exception from being handled by Tomcat then we need to handle Throwable which is the super class
		
			@Provider		-> register the below class with JAX-RS
			public class GenericExceptionMapper implements ExceptionMapper<Throwable> {
				@Override
				public Response toResponse(Throwable ex) {
				
					return Response.status(Status.INTERNAL_SERVER_ERROR)
									.entity(new ErrorMessage(ex.getMessage(), 500, "link to documentation"))
									.build();
				}
			}
		
		(OR)
		
		3. Jersey already registered one Exception for us WebApplicationException which we can use
		
			public Comment getComment(long msgId, long commnetId) {
			
				Message message= messageService.getMessage(msgId);
				if(message==null)
					throw new WebApplicationException(Response.status(Status.NOT_FOUND)
									.entity(new ErrorMessage("Message not found", 404, "link to documentation"))
									.build());
				
				Comment comment= message.getComments(commentId);
				if(comment==null)
					throw new WebApplicationException(Response.status(Status.NOT_FOUND)
									.entity(new ErrorMessage("Comment not found", 404, "link to documentation"))
									.build());
			}
	
		javax.ws.rs.WebApplicationException (extends RunTimeException extends Exception extends Throwable extends Object) 
			contains some subclasses
		
			1. ClientErrorException	-	4xx
				Subclasses: BadRequestException, ForbiddenException, NotAcceptableException, NotAllowedException, 
							NotAuthorizedException, NotFoundException, NotSupportedException
							
			2. RedirectionException	-	3xx
				Subclasses: -
				
			3. ServerErrorException	-	5xx
				Subclasses: InternalServerErrorException, ServiceUnavailableException

			
	HATEOAS
	-------
	
		How to implement HATEOAS?
		Simply add a links property in every resource u send as a response.
		Links property is an list of all subresources
		
		@GET
		@Path("{messageId}")
		public Message getMessage(@PathParam long messageId) {
			Message message = messageService.getMessage(messageId);
			message.addLinks(getUriForSelf(uriInfo, message), "self");
			message.addLinks(getUriForProfile(uriInfo, message), "profile");
			message.addLinks(getUriForComments(uriInfo, message), "comments");
			
			return message;
		}	
		
		public String getUriForSelf(UriInfo uriInfo, Message message) {
		
			return uriInfo.getBaseUriBuilder().
					.path(MessageResource.class)
					.path(message.getId())
					.build()
					.toString();
		}
		
		public String getUriForProfile(UriInfo uriInfo, Message message) {
		
			return uriInfo.getBaseUriBuilder().
					.path(ProfileResource.class)
					.path(message.getAuthor())
					.build()
					.toString();
		}
		
		public String getUriForSelf(UriInfo uriInfo, Message message) {
		
			return uriInfo.getBaseUriBuilder().
					.path(MessageResource.class)						-> adds "/messages"
					.path(MessageResource.class, "getCommentResource")	-> adds "/{messageId}/comments"
					.path(CommentResource.class)						-> "/messages/{messageId}/comments"
					.resolveTemplate("messageId", message.getId())		-> "/messages/1/comments"
					.build()
					.toString();
		}
	
		Content Negotiation
		-------------------
		
		Accept 
		------
			This header is used to inform Server what type of content client expects as response.
		
			Server is going to take HttpMethod + HttpPath + Produces as a key and search for the method which serves this request
				otherwise it's going to throw an error 406 Not Acceptable
		
		Content-Type
		------------
			This header is used to inform Server what content is being delivered in request body.
			
			Server is going to take HttpMethod + HttpPath + Consumes as a key and search for the method which serves this request
			
			
			
			
			
			
			
			
			
			
			
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	





















	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		