It helps create stand-alone, production-grade Spring based applications with minimal effort. 
It does not use XML configurations anymore and implements the convention over configuration principle.

Spring boot is a way in which u can bootstrap or quickly startup a spring application.
We can easily create Production ready application in a matter of seconds.

Spring is spring application and boot is bootstrap

Official definition: 
Spring boot makes it easy to create standalone Prod-grade Spring based applications that you can just run.

What is Spring ? 

Application framework - Enterprise java applications

Programming and configuration model - allows us to focus on business problem, takes care of other things like 
for a service class if we annotate with @service then it manages the life cycle of that class and does lot more things

Infrastructure support - easily connect to any DB while leveraging spring

Problems 

1. Huge framework
2. Multiple setup steps
3. Multiple configuration steps
4. Multiple build and deploy steps

Can we abstract these steps???

Spring Boot
------------

1. Opinionated - meaning: someone who like share their opinion
It makes certain config choices/decisions for us and says start with this and lets u start with it, and then later on 
if required we can make our own choice whether to change it

2. Convention over configuration: 
Majority use case it works. For 80% the config provided by sb works, for 20% u can change the config

3. Stand alone: gives apring app which is stand alone. It gives u something which can directly run.
contains a web container.

4. Production ready

---------------------------------

Requirements:

Spring Tool SUite
Maven -> Build tool, Dependancy management tool, contains archetype
Java8
------------------------------------


Create a default maven project

Add the following in pom

  <parent>
  	<groupId>org.springframework.boot</groupId>
  	<artifactId>spring-boot-starter-parent</artifactId>
  	<version>1.4.2.RELEASE</version>
  </parent>
  
  <dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
  	</dependency>  	
  </dependencies>
  
  The parent is giving us the configuration, and dependancies are those jars getting downloaded
  for ex: if we change version in parent from 1.4.2 to 1.0.0 then the jars downloaded would actually be older one's.
  tomcat-embed-core-8.5.6.jar would change to tomcat-embed-core-7.0.52.jar
  
  This is called Bill of materials. It means that for each version in parent, 
  there is a combination of dependencies that are compatible to work with will get downloaded.
  
Now all the default dependancies get downloaded for creating a spring web application.

Create a simple java class with main method.

Annotate the class with @SpringBootApp

Inside the main method we need to register this class with Spring boot
we do that by calling static run method (adding below line)

SprintApplication.run(App.class, args);

Then run the application as Java application.

Spring boot does the following:
-------------------------------
1. Sets up default configuration
2. Starts Spring app context
3. Performs classpath scans
4. Starts tomcat server

Embedded Tomcat server
-------------------------------
1. Convenience
2. Servlet container config is now application config
3. Standalone application
4. Useful for microservices architecture


Different ways to create Spring boot app

1. Spring Intializr
	Go to https://start.spring.io/ 
	Choose the kind of project you want
	It will give u a pom which u can download
	U can import the pom into ur eclipse projects
	
2. Spring boot CLI(command line interface)

3. Spring Tool Suite
	Choose all the options and click on generate 
	It communicates with start.spring.io over the internet 
	and downloads the project and opens it in the IDE as a project




@Bean - indicates that a method produces a bean to be managed by Spring.
@Service - indicates that an annotated class is a service class.
@Repository - indicates that an annotated class is a repository, which is an abstraction of data access and storage.
@Configuration - indicates that a class is a configuration class that may contain bean definitions.
@Controller - marks the class as web controller, capable of handling the requests.
@RequestMapping - maps HTTP request with a path to a controller method.
@Autowired - marks a constructor, field, or setter method to be autowired by Spring dependency injection.
@SpringBootApplication - enables Spring Boot autoconfiguration and component scanning.
@Component is a generic stereotype for a Spring managed component. It turns the class into a Spring bean at the auto-scan time. Classes decorated with this annotation are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning. 
@Repository, @Service, and @Controller are specializations of @Component for more specific use cases.

There are also Hibernate @Entity, @Table, @Id, and @GeneratedValue annotations in the example.

@SpringBootApplication encapsulates 
@Configuration, @EnableAutoConfiguration, and @ComponentScan annotations with their default attributes.

1. @Configuration - will be bootstrapped by Spring and used to instantiate beans.
helps in Spring annotation based configuration. Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime.

ex: Use @Configuration annotation on top of any class to declare that this class provides one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime.

AppConfig.java
@Configuration
public class AppConfig {
 
    @Bean(name="demoService")
    public DemoManager service()
    {
		return new DemoManagerImpl();
    }
}

@ComponentScan - This annotation is used with the @Configuration annotation to allow Spring to know the packages to scan for annotated components. 
1. basePackageClasses 
2. basePackage 
3. default - when above atts are not defined then it will scan all packages below this package 
 
@Bean
This annotation is used at the method level. The @Bean annotation works with @Configuration to create Spring beans. As mentioned earlier, @Configuration will have methods to instantiate and configure dependencies. Such methods will be annotated with @Bean. The method annotated with this annotation works as the bean ID, and it creates and returns the actual bean.

@Lazy
This annotation is used on component classes. By default, all autowired dependencies are created and configured at startup. But if you want to initialize a bean lazily, you can use the @Lazy annotation over the class. This means that the bean will be created and initialized only when it is first requested for. You can also use this annotation on @Configuration classes. This indicates that all @Bean methods within that @Configuration should be lazily initialized. 

@Value
is used to assign default values to variables and method arguments. 
We can read spring environment variables as well as system variables using @Value annotation.
Spring @Value annotation also supports SpEL.
Ex: below

public class DBConnection {

	@Value("${DB_DRIVER_CLASS}")	//present in properties file
	private String driverClass;
	@Value("${DB_URL}")
	private String dbURL;
	@Value("${DB_USERNAME}")
	private String userName;
	@Value("${DB_PASSWORD}")
	private char[] password;

	public DBConnection() {
	}

	public void printDBConfigs() {
		System.out.println("Driver Class = " + driverClass);
		System.out.println("DB URL = " + dbURL);
		System.out.println("User Name = " + userName);

		// Never do below in production environment :D
		System.out.println("Password = " + String.valueOf(password));
	}
}

@Configuration
@PropertySource("classpath:db.properties")
@PropertySource(value = "classpath:root.properties", ignoreResourceNotFound = true)
public class DBConfiguration {

	@Value("Default DBConfiguration")
	private String defaultName;

	@Value("true")
	private boolean defaultBoolean;

	@Value("10")
	private int defaultInt;

	@Value("${APP_NAME_NOT_FOUND:Default}")
	private String defaultAppName;

	// @Value("#{systemProperties['java.home']}")
	@Value("${java.home}")
	private String javaHome;

	@Value("${HOME}")
	private String homeDir;

	@Bean
	public DBConnection getDBConnection() {
		DBConnection dbConnection = new DBConnection();
		return dbConnection;
	}

	@Value("Test")	//default value for all args if not present
	public void printValues(String s, @Value("another variable") String v) {
		System.out.println("Input Argument 1 =" + s);
		System.out.println("Input Argument 2 =" + v);

		System.out.println("Home Directory = " + homeDir);
		System.out.println("Default Configuration Name = " + defaultName);
		System.out.println("Default App Name = " + defaultAppName);
		System.out.println("Java Home = " + javaHome);
		System.out.println("Boolean = " + defaultBoolean);
		System.out.println("Int = " + defaultInt);

	}

}


@CrossOrigin
This annotation is used both at the class and method levels to enable cross-origin requests. In many cases, the host that serves JavaScript will be different from the host that serves the data. In such a case, Cross Origin Resource Sharing (CORS) enables cross-domain communication. 
By default, the @CrossOrigin annotation allows all origin, all headers, the HTTP methods specified in the@RequestMapping annotation, and a maxAge of 30 min. You can customize the behavior by specifying the corresponding attribute values.

Ex: Below
@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {
    @CrossOrigin(origins = "http://example.com")
    @RequestMapping("/message")
    public Message getMessage() {
        // ...
    }
    @RequestMapping("/note")
    public Note getNote() {
        // ...
    }
}


-----------------------
2. @EnableAutoConfiguration annotation auto-configures the beans that are present in the classpath. 
Auto-configuration classes are normal @Configuration annotated classes only.
This simplifies the developers work by guessing the required beans from the classpath and configure it to run the application.
For example, if you have tomcat-embedded.jar in the classpath, then you will need a TomcatEmbeddedServletContainerFactory bean to configure the tomcat server. 
This will be searched and configured without any manual XML configurations.
It is generally recommended that you place @EnableAutoConfiguration in a root package so that all sub-packages and classes can be searched.
Attributes: 
1. exclude
2. excludeTypes

Auto-Configuration Conditions
Usually, when we write our custom auto-configurations, we want Spring to use them conditionally. We can achieve this with the annotations in this section.

We can place the annotations in this section on @Configuration classes or @Bean methods.

4.1. @ConditionalOnClass and @ConditionalOnMissingClass
Using these conditions, Spring will only use the marked auto-configuration bean if the class in the annotation’s argument is present/absent:

@Configuration
@ConditionalOnClass(DataSource.class)
class MySQLAutoconfiguration {
    //...
}
4.2. @ConditionalOnBean and @ConditionalOnMissingBean
We can use these annotations when we want to define conditions based on the presence or absence of a specific bean:

@Bean
@ConditionalOnBean(name = "dataSource")
LocalContainerEntityManagerFactoryBean entityManagerFactory() {
    // ...
}
4.3. @ConditionalOnProperty
With this annotation, we can make conditions on the values of properties:

@Bean
@ConditionalOnProperty(
    name = "usemysql", 
    havingValue = "local"
)
DataSource dataSource() {
    // ...
}
4.4. @ConditionalOnResource
We can make Spring to use a definition only when a specific resource is present:

@ConditionalOnResource(resources = "classpath:mysql.properties")
Properties additionalProperties() {
    // ...
}
4.5. @ConditionalOnWebApplication and @ConditionalOnNotWebApplication
With these annotations, we can create conditions based on if the current application is or isn’t a web application:

@ConditionalOnWebApplication
HealthCheckController healthCheckController() {
    // ...
}
4.6. @ConditionalExpression
We can use this annotation in more complex situations. Spring will use the marked definition when the SpEL expression is evaluated to true:

@Bean
@ConditionalOnExpression("${usemysql} && ${mysqlserver == 'local'}")
DataSource dataSource() {
    // ...
}
4.7. @Conditional
For even more complex conditions, we can create a class evaluating the custom condition. We tell Spring to use this custom condition with @Conditional:

@Conditional(HibernateCondition.class)
Properties additionalProperties() {
    //...
}

Exploring the Power of @Conditional 
While developing Spring based applications we may come across a need to register beans conditionally.

For example, you may want to register a DataSource bean pointing to the dev database while running application locally and point to a different production database while running in production. 

You can externalize the database connection parameters into the properties file and use the file appropriate for the environment, but you need to change the configuration whenever you need to point to a different environment and build the application.

To address this problem, Spring 3.1 introduced the concept of Profiles. You can register multiple beans of the same type and associate them with one or more profiles. When you run the application you can activate the desired profiles and beans associated with the activated profiles, and only those profiles will be registered.

@Configuration
public class AppConfig
{
 @Bean
 @Profile("DEV")
 public DataSource devDataSource() {
 ...
 }
 @Bean
 @Profile("PROD")
 public DataSource prodDataSource() {
 ...
 }
}
Then you can specify the active profile using System Property -Dspring.profiles.active=DEV.

This approach works for simple cases like enable or disable bean registrations based on activated profiles. But if you want to register beans based on some conditional logic then the profiles approach itself is not sufficient.

To provide more flexibility for registering Spring beans conditionally, Spring 4 introduced the concept of @Conditional. By using the @Conditional approach you can register a bean conditionally based on any arbitrary condition.

For example, you may want to register a bean when:

A specific class is present in classpath
A Spring bean of certain type doesn’t already registered in ApplicationContext
A specific file exists on a location
A specific property value is configured in a configuration file
A specific system property is present/absent
These are just a few examples only and you can have any condition you want.

Let us take a look at how Spring’s @Conditional works.

Suppose we have a UserDAO interface with methods to get data from a data store. We have two implements of UserDAO interface namely JdbcUserDAO which talks to MySQL database and MongoUserDAO which talks to MongoDB.

We may want to enable only one interface of JdbcUserDAO and MongoUserDAO based on a System Property, say dbType.

If the application is started using java -jar myapp.jar -DdbType=MySQL, then we want to enable JdbcUserDAO. Otherwise, if the application is started using java -jar myapp.jar -DdbType=MONGO, we want to enable MongoUserDAO.

Suppose we have a UserDAO bean and a JdbcUserDAO bean. The MongoUserDAO implementation is as follows:

public interface UserDAO
{
 List<String> getAllUserNames();
}
public class JdbcUserDAO implements UserDAO
{
 @Override
 public List<String> getAllUserNames()
 {
 System.out.println("**** Getting usernames from RDBMS *****");
 return Arrays.asList("Siva","Prasad","Reddy");
 }
}
public class MongoUserDAO implements UserDAO
{
 @Override
 public List<String> getAllUserNames()
 {
 System.out.println("**** Getting usernames from MongoDB *****");
 return Arrays.asList("Bond","James","Bond");
 }
}
We can implement the Condition MySQLDatabaseTypeCondition to check whether the System Property dbType is "MYSQL" as follows:

public class MySQLDatabaseTypeCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
 {
 String enabledDBType = System.getProperty("dbType");
 return (enabledDBType != null && enabledDBType.equalsIgnoreCase("MYSQL"));
 }
}
We can implement the Condition MongoDBDatabaseTypeCondition to check whether the System Property dbType is "MONGODB" as follows:

public class MongoDBDatabaseTypeCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
 {
 String enabledDBType = System.getProperty("dbType");
 return (enabledDBType != null && enabledDBType.equalsIgnoreCase("MONGODB"));
 }
}
Now we can configure both JdbcUserDAO and MongoUserDAO beans conditionally using @Conditional as follows:

@Configuration
public class AppConfig
{
 @Bean
 @Conditional(MySQLDatabaseTypeCondition.class)
 public UserDAO jdbcUserDAO(){
 return new JdbcUserDAO();
 }
 @Bean
 @Conditional(MongoDBDatabaseTypeCondition.class)
 public UserDAO mongoUserDAO(){
 return new MongoUserDAO();
 }
}
If we run the application like java -jar myapp.jar -DdbType=MYSQL then only the JdbcUserDAO bean will be registered.But if you set the System property like -DdbType=MONGODB then only the MongoUserDAO bean will be registered.

Now that we have seen how to conditionally register a bean based on System Property.

Suppose we want to register MongoUserDAO bean only when MongoDB java driver class "com.mongodb.Server" is available on classpath, if not we want to register JdbcUserDAO bean.

To accomplish that we can create Conditions to check the presence or absence of MongoDB driver class "com.mongodb.Server" as follows:

public class MongoDriverPresentsCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext,AnnotatedTypeMetadata metadata)
 {
	 try {
		Class.forName("com.mongodb.Server");
	 return true;
	 } catch (ClassNotFoundException e) {
		return false;
	 }
 }
}
public class MongoDriverNotPresentsCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
 {
	 try {
		Class.forName("com.mongodb.Server");
	 return false;
	 } catch (ClassNotFoundException e) {
		return true;
	 }
 }
}
We just have seen how to register beans conditionally based on the presence or absence of a class in classpath.

What if we want to register the MongoUserDAO bean only if no other Spring bean of the type UserDAO is already registered.

We can create a Condition to check if there is any existing bean of a certain type as follows:

public class UserDAOBeanNotPresentsCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
 {
	 UserDAO userDAO = conditionContext.getBeanFactory().getBean(UserDAO.class);
	 return (userDAO == null);
 }
}
What if we want to register MongoUserDAO bean only if property app.dbType=MONGO is set in properties placeholder configuration file?

We can implement that Condition as follows:

public class MongoDbTypePropertyCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
 {
	 String dbType = conditionContext.getEnvironment().getProperty("app.dbType");
	 return "MONGO".equalsIgnoreCase(dbType);
 }
}
We have just seen how to implement various types of Conditions.But there is even more elegant way to implement Conditions using Annotations. Instead of creating a Condition implementation for both MYSQL and MongoDB, we can create aDatabaseType annotation as follows:

@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Conditional(DatabaseTypeCondition.class)
public @interface DatabaseType
{
 String value();
}
Then we can implement DatabaseTypeCondition to use the DatabaseType value to determine whether to enable or disable bean registration as follows:

public class DatabaseTypeCondition implements Condition
{
 @Override
 public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)
 {
	 Map<String, Object> attributes = metadata.getAnnotationAttributes(DatabaseType.class.getName());
	 String type = (String) attributes.get("value");
	 String enabledDBType = System.getProperty("dbType","MYSQL");
	 return (enabledDBType != null && type != null && enabledDBType.equalsIgnoreCase(type));
 }
}
Now we can use the @DatabaseType annotation on our bean definitions as follows:

@Configuration
@ComponentScan
public class AppConfig
{
	 @DatabaseType("MYSQL")
	 public UserDAO jdbcUserDAO(){
		return new JdbcUserDAO();
	 }
	 @Bean
	 @DatabaseType("MONGO")
	 public UserDAO mongoUserDAO(){
		return new MongoUserDAO();
	 }
}
Here we are getting the metadata from DatabaseType annotation and checking against the System Property dbType value to determine whether to enable or disable the bean registration.

We have seen good number of examples to understand how we can register beans conditionally using @Conditional annotation.

Spring Boot extensively uses @Conditional feature to register beans conditionally based on various criteria.

You can find various Condition implementations that SpringBoot uses in org.springframework.boot.autoconfigure package of spring-boot-autoconfigure-{version}.jar.

Now that we've come to know about how Spring Boot uses the @Conditional feature to conditionally check whether to register a bean or not, but what exactly triggers the auto-configuration mechanism?

This is what we are going to look at in the next section.

Spring Boot AutoConfiguration 
The key to the Spring Boot’s auto-configuration magic is @EnableAutoConfiguration annotation. Typically we annotate our Application entry point class with either @SpringBootApplication or if we want to customize the defaults we can use the following annotations:

@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application
{
}
The @EnableAutoConfiguration annotation enables the auto-configuration of Spring ApplicationContext by scanning the classpath components and registers the beans that are matching various Conditions.

SpringBoot provides various AutoConfiguration classes in spring-boot-autoconfigure-{version}.jar, which are responsible for registering various components.

Typically AutoConfiguration classes are annotated with @Configuration to mark it as a Spring configuration class and annotated with @EnableConfigurationProperties to bind the customization properties and one or more Conditional bean registration methods.

For example, consider the org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration class.

@Configuration
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })
public class DataSourceAutoConfiguration 
{
	 ...
	 ...
	 @Conditional(DataSourceAutoConfiguration.EmbeddedDataSourceCondition.class)
	 @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	 @Import(EmbeddedDataSourceConfiguration.class)
	 protected static class EmbeddedConfiguration {
	 }
	 @Configuration
	 @ConditionalOnMissingBean(DataSourceInitializer.class)
	 protected static class DataSourceInitializerConfiguration {
	 @Bean
	 public DataSourceInitializer dataSourceInitializer() {
	 return new DataSourceInitializer();
	 }
	 }
	 @Conditional(DataSourceAutoConfiguration.NonEmbeddedDataSourceCondition.class)
	 @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	 protected static class NonEmbeddedConfiguration {
		 @Autowired
		 private DataSourceProperties properties;
		 @Bean
		 @ConfigurationProperties(prefix = DataSourceProperties.PREFIX)
		 public DataSource dataSource() {
			 DataSourceBuilder factory = DataSourceBuilder
			 .create(this.properties.getClassLoader())
			 .driverClassName(this.properties.getDriverClassName())
			 .url(this.properties.getUrl()).username(this.properties.getUsername())
			 .password(this.properties.getPassword());
			 if (this.properties.getType() != null) {
				factory.type(this.properties.getType());
			 }
			 return factory.build();
		 }
	 }
	 ...
	 ...
	 @Configuration
	 @ConditionalOnProperty(prefix = "spring.datasource", name = "jmx-enabled")
	 @ConditionalOnClass(name = "org.apache.tomcat.jdbc.pool.DataSourceProxy")
	 @Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)
	 @ConditionalOnMissingBean(name = "dataSourceMBean")
	 protected static class TomcatDataSourceJmxConfiguration {
	 @Bean
	 public Object dataSourceMBean(DataSource dataSource) {
	 ....
	 ....
	 }
	 }
	 ...
	 ...
}
Here, DataSourceAutoConfiguration is annotated with @ConditionalOnClass({ DataSource.class,EmbeddedDatabaseType.class }) which means that the AutoConfiguration of beans within DataSourceAutoConfiguration will be considered only if the DataSource.class and EmbeddedDatabaseType.class classes are available on classpath.

The class is also annotated with @EnableConfigurationProperties(DataSourceProperties.class) which enables binding the properties in application.properties to the properties of DataSourceProperties class automatically.

@ConfigurationProperties(prefix = DataSourceProperties.PREFIX)
public class DataSourceProperties implements BeanClassLoaderAware, EnvironmentAware, InitializingBean {
 public static final String PREFIX = "spring.datasource";
 ...
 ...
 private String driverClassName;
 private String url;
 private String username;
 private String password;
 ...
 //setters and getters
}
With this configuration all the properties that starts with spring.datasource.* will be automatically binds to DataSourceProperties object.

spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=secret
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
You can also see some inner classes and bean definition methods that are annotated with SpringBoot’s Conditional annotations such as @ConditionalOnMissingBean, @ConditionalOnClass and @ConditionalOnProperty etc.

These bean definitions will be registered in ApplicationContext only if those conditions are matched.

You can also explore many other AutoConfiguration classes in spring-boot-autoconfigure-{version}.jar such as:

org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration 
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration 
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration 
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfigurationetc etc. 

I hope now you have an understanding of how Spring Boot auto-configuration works by using various AutoConfiration classes along with @Conditional features.


--------------------------------------------------------------------

@Required
---------
This annotation is applied to bean setter methods. Consider a scenario where you need to enforce a required property. The @Required annotation indicates that the affected bean must be populated at configuration time with the required property. Otherwise, an exception of type BeanInitializationException is thrown.

@Autowired
-----------
This annotation is applied to fields, setter methods, and constructors. The @Autowired annotation injects object dependency implicitly.

When you use @Autowired on fields and pass the values for the fields using the property name, Spring will automatically assign the fields with the passed values.

There are different ways through which we can autowire a spring bean.

1. Autowire byName – For this type of autowiring, setter method is used for dependency injection. Also the variable name should be same in the class where we will inject the dependency and in the spring bean configuration file.
2. Autowire byType – For this type of autowiring, class type is used. So there should be only one bean configured for this type in the spring bean configuration file.
3. Autowire by constructor – This is almost similar to autowire byType, the only difference is that constructor is used to inject the dependency.

@Qualifier
----------
This annotation is used along with the @Autowired annotation. 
This annotation is used to avoid the confusion that occurs when you create more than one bean of the same type and want to wire only one of them with a property.

ex: BeanInterface is implemented by two beans, BeanB1 and BeanB2.
@Component
public class BeanA {
    @Autowired
    @Qualifier("beanB2")
    private IBean dependency;
    ...
}

With the @Qualifier annotation added, Spring will now know which bean to autowire, where beanB2 is the name of BeanB2.

---------------------------------------------------------------------------------------
SpringApplication.run() method
------------------------------

1. Main app context is kicked off (where it searches for all the classes annotated with @Configuration, initializes all the beans inside
the configuration classes and stores them in IOC container within JVM.)
	1.1. Create application context
	1.2. Check application type (SERVLET/ REACTIVE/ DEFAULT) default-> AnnotationConfigApplicationContext
	1.3. Register the annotated class beans with the context
2. Creates an instance of TomcatEmbeddedServletContainer and adds it to the context
3. Automatically configures DispatcherServlet and registers default handler mappings, messageConverts and other basic things.





-------------------------------------------------------------------------------

Let’s understand the details of some of the important files and directories -

1. EasyNotesApplication

This is the main entry point of our Spring Boot application.

package com.example.easynotes;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class EasyNotesApplication {

	public static void main(String[] args) {
		SpringApplication.run(EasyNotesApplication.class, args);
	}
}

It contains a simple annotation called @SpringBootApplication which is a combination of the following more specific spring annotations -

@Configuration : Any class annotated with @Configuration annotation is bootstrapped by Spring and is also considered as a source of other bean definitions.

@EnableAutoConfiguration : This annotation tells Spring to automatically configure your application based on the dependencies that you have added in the pom.xml file.

For example, If spring-data-jpa or spring-jdbc is in the classpath, then it automatically tries to configure a DataSource by reading the database properties from application.properties file.

@ComponentScan : It tells Spring to scan and bootstrap other components defined in the current package (com.example.easynotes) and all the sub-packages.

The main() method calls Spring Boot’s SpringApplication.run() method to launch the application.

2. resources/

This directory, as the name suggests, is dedicated to all the static resources, templates and property files.

resources/static - contains static resources such as css, js and images.

resources/templates - contains server-side templates which are rendered by Spring.

resources/application.properties - This file is very important. It contains application-wide properties. Spring reads the properties defined in this file to configure your application. You can define server’s default port, server’s context path, database URLs etc, in this file.

You can refer this page for common application properties used in Spring Boot.

3. EasyNotesApplicationTests - Define unit and integration tests here.

4. pom.xml - contains all the project dependencies

Lazy Initialization
-------------------

Lazily initialize the beans and inject them into their dependencies only when required.

Generally when the Spring boot app starts it inits all the beans in spring app context and injects them into dependencies.
So in order to deviate from default behavior and initialize only when required is Lazy Initialization.

***Proof: This can be verified by having a sysout in the constructor of the bean.

To enable this we need to set property in application.properties

spring.main.lazy-initialization= true

This applies across application.

But when u want to lazily load only some components then u can specify @Lazy annotation for them alone and in their dependencies.

Pros: 
1. start up is fast
2. 
Cons
1. can result in NoClassDefFoundError in dependencies if not dealt with property
2. Heavy end points will result in performance degradation
-------------------------------------------------
Profiles 
--------

Use profiles when u want to switch between different environments

we can set the profile as (In the environment variables of spring boot app)
also can be specified in argument -Dspring.profiles.active=DEV

spring.profile.active= DEV

and specify properties specific to DEV in application-DEV.properties file

The @Configuration class can use the profile using

@Profile("DEV") -> To use this configuration for DEV
@Profile("!DEV") -> NOT use this configuration for DEV

-------------------------------------------------
Transactionality
----------------

@Transactional informs spring boot what to consider as a transaction and apply ACID properties

If we place this annotation at the service level, then if there is issue for one of the users
then none will be saved.

@Transactional
public void save(List<User> users) {
	users.forEach(user -> userRepository.save(user));
}

If we place it at the repo level then only that user won't be saved.
------------------------------------------------
Actuators
---------

To monitor the webapplication inside a spring boot app

spring-boot-actuator dependency need to be added

/env - provides env specific info like profiles, server ports, servletContextInitParams, 
systemProperties like jvm level, jdk level, os level, user level, java classpath and also
applicationConfig: [classpath:/application.properties] as well

/metrics- provides the memory related props
jvm memory, heap memeory, threads, gc etc

/trace - last few requests for this end point

/health - provides the status of the endpoint


Can create a CustomEndpoint which shd implement Endpoint<?>
1. String getId() - endpoint url
2. boolean isEnabled()
3. boolean isSensitive()
4. ? invoke() - return appropriate data as a response when this endpoint is accessed
-------------------------------------------------



























