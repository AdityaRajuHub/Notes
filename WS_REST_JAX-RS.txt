
REST	- Roy Fielding	- also author of Http specifications
----

Representational State Transfer: is transferring the state of a resource over the internet to the client.
		The state of a resource can be represented using XML/JSON format.

	So when a browser requests a server for data, server responds with a web page. 
	But what if an app requests data and it can't interpret a webpage
		in that case we need to transer state in the form of XML/JSON


SOAP 	- 	WSDL

REST	- 	No Service Definition
			No standards, rules
			Hence the name RESTful
			

	Let's duug HTTP
	
	What is HyperText?
	A.	Hyper Text is text which contains Hyper Links.
		HyperLinks are links to other text. ex: HTML which contains anchor tags linking to other pages

	(1) REST uses HTTP which uses Resource based URI's which contains Nouns not Verbs

		1. Addresses: 			invokes an action on server to do something
		
		2. Resource based URI: 	lookup a resource at a location
		
			Ex: Weather website
			
			Address: 	weatherapp.com/weatherLookup.do?zipcode=12345
			URI:		weatherapp.com/zipcode/12345
		
	(2) REST uses HTTP methods to lookup/alter a resource at a URI
	
		GET				/topics				Gets all topics 	- Idempotent
		GET				/topics/id			Gets the topic 		- Idempotent
		POST			/topics				Create new topic 	- Not Idempotent(creates mutiple resources)
		PUT				/topics/id			Update the topic 	- Idempotent
		DELETE			/topics/id			Delete the topic 	- Idempotent
	
		Idempotent		-	has the same effect even if invoked multiple times 		ex: count=100;
		Not Idempotent	- 	affects multiple resources if invoked multiple times	ex: count=count+1;
		
	****So Resource creation should be done by POST, the browser issues a warning if you are invoking the request again.
	
	(3) REST uses HTTP status codes to know about the status of the request
		
		1xx	-	Informational
		
		2xx	- 	Successful responses
				ex: 200 OK, 201 Created, 202 Accepted, 204 No content
		
		3xx	-	Redirection messages
				ex: 301 Moved Permanently, 304 Not modified
		
		4xx	-	Client error responses
				ex: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found
		
		5xx	-	Server error responses
				ex: 500 Internal Server Error, 502 Bad Gateway, 504 Gateway Timeout, 
		
		
	(4) REST uses HTTP Headers for knowing about the message 
		Headers contains Metadata.
	
		Http protocol 	1.1
		Http method		GET/POST/PUT/DELETE
		Content-Type:	text/xml, application/json
		Message Length
		Date		
		
	2 types of URI's
		
		1. Instance based URI			-	which means it returns a single instance of resource
		2. Collection Resource URI		-	which means it returns a collection of resource instances.
		
		
	1. Get all messages	-	Collection URI
	
		/messages
	
	2. Getting a message -	Instance URI	
	
		/messages/{messageId}
		
	3. Get all comments to a message -	Collection
		
		/messages/{messageId}/comments
	
		So /messages acts as a directory for all the comments for a message
		
		.../comments is a Collection URI 
	
	Filtering results	-	Query parameters
	-----------------
		
		/messages?offset=30&limit=10
		
		/messages?year=2014&offset=30&limit=10


	Http Methods
	------------
	
		We can have same URI's for multiple operations
		Using the right method we can perform the right operation
		
		/getProducts.do?id=10		->	GET /products/10
		
		/deleteProducts.do?id=10	->	DELETE /products/10
		
		
	REST response
	-------------
	JSON / XML
	
	The advantage of JSON over XML is that JSON can be easily converted to a webpage using JSON object for human consumption.


	HATEOAS
	-------
		Hypermedia as the Engine of Application State
		
		which means that hyper text is driving the client's interation with application.
		
		if user requests for a resource then the response could contain other resources uri's along with the actual resource.
		
		So the client developer need not hard code the uri's
		
		Request: 	GET	/api/messages/
		Response:
			[
				{
					"id": 10,
					"name": "REST API",
					"description": "Rest API by Roy Fielding",
					"href": "/messages/10"
					"likes-href"; "/api/messages/10/likes",
					"comments-href": "/api/messages/10/comments",
					"shares-href": "/api/messages/10/shares"
				},
				{
					"id": 20,
					"name": "Java",
					"description": "Java Black Book",
					"href": "/messages/20"
					"likes-href"; "/api/messages/20/likes",
					"comments-href": "/api/messages/20/comments",
					"shares-href": "/api/messages/20/shares"
				},
				{
					"id": 30,
					"name": "Javascript",
					"description": "Javascript is the future",
					"href": "/messages/30"
					"likes-href"; "/api/messages/30/likes",
					"comments-href": "/api/messages/30/comments",
					"shares-href": "/api/messages/30/shares"
				}
			]

		Observe that each resource in the collection consists of href property 
			which can be used to get that resource.
			
		This could be further improved by using "rel" attribute which is a HTTP attribute.

			[
				{
					"id": 10,
					"name": "REST API",
					"description": "Rest API by Roy Fielding",
					"links": [
								{
									"href": "/messages/10",
									"rel": "self"
								},
								{
									"href": "/api/messages/10/likes",
									"rel": "likes"
								},
								{
									"href": "/api/messages/10/comments",
									"rel": "comments"
								},
								{
									"href": "/api/messages/10/shares",
									"rel": "shares"
								}
							]
				}
			]

		With "rel" it is easy to find the resource that the client wants.

	Richardson Maturity Model
	---------------------------
	
		Tells us how well we have implemented RESTful WS
		
		1. Level 0	-	Swamp of POX (Plain Old XML)
							It is when the request XML contains operation name and parameters
							<create-request><id>10</id><name>Java</name></create-request>
							
		2. level 1	-	Resource URI
		
		3. Level 2	-	HTTP Methods + Resource URI
		
		4. Level 3	-	HATEOAS + HTTP Methods + Resource URI
		
	---------------------------------------------------------------------------------------------------
	
	Implementing REST API through JAX-RS (javax.ws.rs.*)
	---------------------
		
		JAX-RS is the specification which is implemented by many libraries like Jersey, RESTEasy etc.
		
		The specifications contains annotations and interfaces which the libraries implement,
			which means u can plugin any library u want and it will still work.
		
		Why Jersey?
		----------
			It is a reference implementation for JAX-RS.
			
		Maven archetype
		---------------
		Group Id:		org.glassfish.jersey.archetypes
		Artifact Id: 	jersey-quickstart-webapp
		Version:		2.14
		
			> mvn archetype:generate -DarchetypeGroupId=org.glassfish.jersey.archetypes -DarchetypeArtifactId=jersey-quickstart-webapp
		
		You can generate an Eclipse project from your Maven project by running

			> mvn eclipse:eclipse
		
		A project will be generated with the following web.xml
		
		<web-app>
			<servlet>
				<servlet-name>Jersey Web Application</servlet-name>
				<servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
				<init-param>
					<param-name>jersey.config.server.provider.packages</param-name>			-> the packages which contain the REST resource handlers
					<param-value>com.example.demo</param-value>
				</init-param>
				<load-on-startup>1</load-on-startup>
			</servlet>
			<servlet-mapping>
				<servlet-name>Jersey Web Application</servlet-name>
				<url-pattern>/webapi/*</url-pattern>
			</servlet-mapping>
		</web-app>
		
	Annotations:
	-----------
	
	1. @Path									- 	class level and method level annotation
	
	2. @GET, @POST, @PUT, @DELETE				- 	place on method
	
	3. @Produces(MediaType.PLAIN_TEXT)			-	class and method level annotation
													signifies response content type
													JAXB does the conversion between Java POJO's and XML
													We need to add the dependency jars for converting JSON and Java POJo
													
	4. @Consumes(MediaType.APPLICATION_JSON)	-	class and method level annotation 
													signifies Request body content type
	
	4. @PathParam								- 	field and method level annotation for maping uri param with method parameters
													field level annotation doesn't work for @Singleton resources
		URI: /messages/1
		
		ex: 1
			@Path(/{profileId}/messages)
			public class MessageResource {
				
				@PathParam private long profileId;
				...
			}
			
		ex: 2 
			@Path("/messages/{messageId}")
			public List<message> getMessage(@PathParam("messageId") String msgId) {...}
		
	5. @QueryParam								-	field and method level annotation for mapping query parameters with method params
													field level annotation doesn't work for @Singleton resources
													Implement pagination using QueryParam
		URI: /messages?year=2014
		@Path("/messages")
		public List<message> getMessage(@QueryParam("year") int year) {...}
		
	6. @MatrixParam								-	method level annotation
		
		URI: /messages;year=2014
		
		Diff between @MatrixParam and @QueryParam
		-----------------------------------------
		The @MatrixParam annotation will apply to particular Resource present in URL and  @QueryParam will apply to whole Request URL.
			
			ex: /inventory/grocery;type=fruits/price;range=300/?limit=10 -	In this URI the params can be placed in between the uri
				First Matrix Param type=fruits is applying to only grocery resource same range=300 is applying to only price resource 
				but Query Param for pagination limit=10 is applying to whole Request URL. And yes, If only query parameters were used, 
				you would end up with parameters like "grocery_type" and "grocery_price" and you would lose the clarity added by the 
				locality of the parameters within the request.
		
		
		
	7. @HeaderParam 							-	extracts information from the HTTP headers. 
													can extract any custom header set in the HTTP Request Header.
	
	8. @CookieParam 							-	extracts information from the cookies declared in cookie related HTTP headers.
	
	9. @Context					 				-	to inject 12 object instances related to the context of HTTP requests.
													same as @Inject
													ex:
													public String getParamsUsingContext(@Context UriInfo uriInfo, @Context HttpHeaders headers) {...}
													
		The object instances that it can inject are the following:

			1. SecurityContext 		– Security context instance for the current HTTP request
			2. Request 				– Used for setting precondition request processing
			3. Application, Configuration, and Providers -> Provide access to the JAX-RS application, configuration, and providers instances
			4. ResourceContext 		– Resource context class instances
			5. ServletConfig 		– The ServletConfig instance instance
			6. ServletContext 		– The ServletContext instance
			7. HttpServletRequest 	– The HttpServletRequest instance for the current request
			8. HttpServletResponse 	– The HttpServletResponse instance for the current request
			9. HttpHeaders 			– Maintains the HTTP header keys and values
			10. UriInfo 			– Query parameters and path variables from the URI called
		
		
	10. @BeanParam								-	used when there are lot of annotated method parameters then u can move them to a POJO
													and create a parameter of POJO as method argument.
													public String getMessages(@BeanParam MessageFilterBean filterBean) {...}
													public class MessageFilterBean{
														@QueryParam private int year;
														@QueryParam private int initial;
														@QueryParam private int size;
														//setters and getters
													}
	
	SubResources
	------------
		A resource within a resource is a subresource.
			ex: comments, likes, shares within a message.
		
		We don't want to have subresources in the main resource itself.
		You have to delegate the request to a subresource.
		The path for the subresource is going to be the remainder path of uri left over by parent resource before
			delegating to the subresource.
		Subresource can access the parent resource Path parameters as well.
		
		Ex: /messages/3/comments
		
			@Path("/messages")
			class MessageResource {
				
				...
				
				@Path("{messageId}/comments")
				public CommentResource getCommentResource() {
					return new CommentResource();
				}
			}
			
			@Path("/")
			class CommentResource {
				
				@GET
				public List<Comment> getComments(@PathParam("messageId") long msgId) {
					...
				}
				
				@GET
				@Path("/{commentId}")
				public List<Comment> getComments(@PathParam("messageId") long msgId, @PathParam("commentId") long cmtId) {
					...
				}
	
			}
	
	Setting Response status codes
	-----------------------------
	
	To return a status code of 201 Created for new resource creation, and returning the resource in body.
		
		Response.status(Status.CREATED)
				.entity(newResource)
				.build();
	
	To return the above and URI for new resource
	
		Response.created(URI uri)	-> URI can be constructed using hardcoding new URI("/resources/"+newResource.getId())
				.entity(newResource)
				.build();
		
		Instead of hardcoding the URI we can also get path from URIInfo of Context and then append new Id.
		
			uriInfo.getAbsolutePathBuilder().path(newResource.getId()).build();
				
	
	Handling Exceptions
	-------------------
		1. To handle DataNotFoundException thrown in our code we need to implement below Mapper to send response 
			instead of Tomcat generated Error Response Html
		
			@Provider		-> register the below class with JAX-RS
			public class DataNotFoundExceptionMapper implements ExceptionMapper<DataNotFoundException> {
			
				@Override
				public Response toResponse(DataNotFoundException ex) {
				
					return Response.status(Status.NOT_FOUND)
									.entity(new ErrorMessage(ex.getMessage(), 404, "link to documentation"))
									.build();
				}
			}	
	
		2. To Handle any Exception from being handled by Tomcat then we need to handle Throwable which is the super class
		
			@Provider		-> register the below class with JAX-RS
			public class GenericExceptionMapper implements ExceptionMapper<Throwable> {
				@Override
				public Response toResponse(Throwable ex) {
				
					return Response.status(Status.INTERNAL_SERVER_ERROR)
									.entity(new ErrorMessage(ex.getMessage(), 500, "link to documentation"))
									.build();
				}
			}
		
		(OR)
		
		3. Jersey already registered one Exception for us WebApplicationException which we can use
		
			public Comment getComment(long msgId, long commnetId) {
			
				Message message= messageService.getMessage(msgId);
				if(message==null)
					throw new WebApplicationException(Response.status(Status.NOT_FOUND)
									.entity(new ErrorMessage("Message not found", 404, "link to documentation"))
									.build());
				
				Comment comment= message.getComments(commentId);
				if(comment==null)
					throw new WebApplicationException(Response.status(Status.NOT_FOUND)
									.entity(new ErrorMessage("Comment not found", 404, "link to documentation"))
									.build());
			}
	
		javax.ws.rs.WebApplicationException (extends RunTimeException extends Exception extends Throwable extends Object) 
			contains some subclasses
		
			1. ClientErrorException	-	4xx
				Subclasses: BadRequestException, ForbiddenException, NotAcceptableException, NotAllowedException, 
							NotAuthorizedException, NotFoundException, NotSupportedException
							
			2. RedirectionException	-	3xx
				Subclasses: -
				
			3. ServerErrorException	-	5xx
				Subclasses: InternalServerErrorException, ServiceUnavailableException

			
	HATEOAS
	-------
	
		How to implement HATEOAS?
		Simply add a links property in every resource u send as a response.
		Links property is an list of all subresources
		
		@GET
		@Path("{messageId}")
		public Message getMessage(@PathParam long messageId) {
			Message message = messageService.getMessage(messageId);
			message.addLinks(getUriForSelf(uriInfo, message), "self");
			message.addLinks(getUriForProfile(uriInfo, message), "profile");
			message.addLinks(getUriForComments(uriInfo, message), "comments");
			
			return message;
		}	
		
		public String getUriForSelf(UriInfo uriInfo, Message message) {
		
			return uriInfo.getBaseUriBuilder().
					.path(MessageResource.class)
					.path(message.getId())
					.build()
					.toString();
		}
		
		public String getUriForProfile(UriInfo uriInfo, Message message) {
		
			return uriInfo.getBaseUriBuilder().
					.path(ProfileResource.class)
					.path(message.getAuthor())
					.build()
					.toString();
		}
		
		public String getUriForSelf(UriInfo uriInfo, Message message) {
		
			return uriInfo.getBaseUriBuilder().
					.path(MessageResource.class)						-> adds "/messages"
					.path(MessageResource.class, "getCommentResource")	-> adds "/{messageId}/comments"
					.path(CommentResource.class)						-> "/messages/{messageId}/comments"
					.resolveTemplate("messageId", message.getId())		-> "/messages/1/comments"
					.build()
					.toString();
		}
	
		Content Negotiation
		-------------------
		
		Accept 
		------
			This header is used to inform Server what type of content client expects as response.
		
			Server is going to take HttpMethod + HttpPath + Produces as a key and search for the method which serves this request
				otherwise it's going to throw an error 406 Not Acceptable
		
		Content-Type
		------------
			This header is used to inform Server what content is being delivered in request body.
			
			Server is going to take HttpMethod + HttpPath + Consumes as a key and search for the method which serves this request

----------------------------------------------------------------------------------------------------------------------------------------			
			
Advanced JAX-RS
---------------

	Index
	-----
		1. Setting up a container agnostic JAX-RS app
		2. Resource lifecycle
		3. Param converters
		4. MessageBodyReader and MessageBodyWriter
		5. Custom MediaTypes
		6. Writing a JAX-RS client
		7. Making a GET and POST request
		8. Handling generic types
		9. Implementing Filter
		10. Interceptors
		11. Rest API Authentication
		12. Implementing Basic Auth
		13. Request Response flow
		
	-------------------------------------------------

Setting up a container agnostic JAX-RS app
------------------------------------------

	Other way of writing a Jersey REST API instead of configuring web.xml is to have a main concrete class extend javax.ws.rs.core.Application
		which is a abstract class. In this way automatically it picks those classes having @Path annotation to be resource handlers of Jersey.
	
		@ApplicationPath("webapi")
		public class MyRestApp extends Application {
		
			...
		}
	
	Application abstract class contains a method 
		
		Set<Class<?>> getClasses() 
			It may be used to return only those classes which are resource handlers.
			
	Resource lifecycle
	------------------
	
		@Singleton		-		All resource handler classes are having default scope as request. 
								So after the request is served the instance will be destroyed.
								If we want to make it singleton then just annotate it with 
								If we have resource handler as singleton then we cannot have path params on top of class
								
								@Path("/messages/{messageId}")	//Not possible for singleton 
								public class Message {...}
		
		@RequestScoped	-		This is the default, resource handler bean created for every request
								can have path params declared on top of class.
			
			
	What if Path param is a custom datatype?
	---------------------------------------
			
		For primitives Jersey automatically converts from String to the particular primitive,
			but if we have custom type as an argument then there would be a ModelValidationException
			Error: No injection resource found for a parameter of type OurCustomType
			
			@Path({whichDate}/date)
			public MyDate getMyDate(@PathParam("whichDate") MyDate date) {	-> whichDate is a string possible values 
																				("today", "tomorrow", "yesterday")
			}
			
			public class MyDate {
				private int date;
				private int month;
				private int year;
				//setters/getters
				...
			}
			
		We can make this conversion happen by implementing ParamConverter 
			and let Jersey know how to do the conversion
		
		It contains a method that we need to implement
			
			T fromString(String value);
			
		Next we need to implement another interface ParamConverterProvider
			which Jersey invokes to check the available converters. So we need to register our converter.
			
			<T> ParamConverter getConverter(Class<T> rawType, Type genericType, Annotation[] annotations)
			
			
		Let's implement the converter for MyDate
		
		@Provider
		public class MyDateConverterProvider implements ParamConverterProvider {
		
			<T> ParamConverter getConverter(Class<T> rawType, Type genericType, Annotation[] annotations) {
			
				if(rawType.getName().equals(MyDate.class.getName())) {
					
					return new ParamConverter<T>() {
						
						@Override
						T fromString(String value) {
							
							Calender requestedDate = Calender.getInstance();
						
							if(value.equals("tomorrow")) {
								requestedDate.add(Calender.DATE, 1);
							}
							else if(value.equals("tomorrow")) {
								requestedDate.substract(Calender.DATE, 1);
							}
							
							MyDate myDate= new MyDate();
							
							myDate.setDate(requestedDate.get(Calender.DATE));
							myDate.setMonth(requestedDate.get(Calender.MONTH));
							myDate.setYear(requestedDate.get(Calender.YEAR));
							
							return rawType.cast(myDate);
						}
					}
				}
			}
		}
	
		
	MessageBodyReader and MessageBodyWriter
	---------------------------------------
	
		Responsible for converting request body into a specific Object and vice versa.
		Automatic conversion happens between JSON, XML to Objects and vice versa since the converters are on the classpath.
		
		But if we were to return TEXT/PLAIN Content-Type and return a Date object from the method then it would throw an exception.
		
		MessageBodyWriter Not found for media type=text/plain, type= class java.util.Date
		
		We need to implement MessageBodyWriter to make this work
		
			@Provider
			@Produces(MediaType.TEXT_PLAIN)
			public class DateMessageBodyWriter implements MessageBodyWriter<Date> {
			
				@Override
				public void writeTo(Date date,
					Class<?> type,
					Type type,
					Annotations[] ann,
					MediaTypes mt,
					MultiValuedMap<String, Object> mvm,
					OutputStream out) throws IOException, WebApplicationException {
					
					out.write(date.toString().getBytes());
				}
				)
			}
		
	Custom MediaType
	----------------
	
	
		
	------------------------------------------------------------------------------------------------------------------	
		
	JAX-RS Client
	-------------
	
		Creating a REST API Client is straight forward
		
		Create a class with main method
		
			Client client = ClientBuilder.newClient();
			
			WebTarget target = client.target("url");
			
			Builder builder = target.request();
			
			Response response = builder.get();	//here response is a wrapper that has access to response headers, cookies etc.
			
			CustomType instance = response.readEntity(CustomType.class);	-> we get our ressource
			
										(OR)
			
			// Build a HTTP GET request that accepts "text/plain" response type
			// and contains a custom HTTP header entry "Foo: bar".
			
			Invocation invocation = resourceTarget.request("text/plain")
												  .header("Foo", "bar")
												  .buildGet();			//request is not yet made just prepared.

			// Invoke the request using generic interface
			String response = invocation.invoke(String.class);
			
			(OR)
			
			//Invoke in 1 step
			String response = resourceTarget.request("text/plain")
											.header("Foo", "bar")
											.get(String.class);
											
		Steps in Request creations
		--------------------------
		
			1. Build the target invocation object with the type of request method and get a WebTarget or Invocation instance.
			2. Invoke the request and get a response object. This is where the actual request is made to the API.
			3. Using the response instance get hold of response header, body etc.
			4. Get a hold of the resource using response object.
			
		----------------------------------------------------------------
		
		javax.ws.rs.client.WebTarget extends Configurable<WebTarget>
		----------------------------
		
			1. URI	getUri()
				Get the URI identifying the resource.
				
			2. UriBuilder	getUriBuilder()
				Get the URI builder initialized with the URI of the current resource target.
				
			3. WebTarget	matrixParam(String name, Object... values)
				Create a new WebTarget instance by appending a matrix parameter to the existing set of matrix parameters 
					of the current final segment of the URI of the current target instance.
					
			4. WebTarget	path(String path)
				Create a new WebTarget instance by appending path to the URI of the current target instance.
				
			5. WebTarget	queryParam(String name, Object... values)
				Create a new WebTarget instance by configuring a query parameter on the URI of the current target instance.
				
			6. Invocation.Builder	request()
				Start building a request to the targeted web resource.
				
			7. Invocation.Builder	request(MediaType... acceptedResponseTypes)
				Start building a request to the targeted web resource and define the accepted response media types.
				
			8. Invocation.Builder	request(String... acceptedResponseTypes)
				Start building a request to the targeted web resource and define the accepted response media types.
				
			9. WebTarget	resolveTemplate(String name, Object value)
				Create a new WebTarget instance by resolving a URI template with a given name in the URI of the current target instance using a supplied value.
				
			10. WebTarget	resolveTemplate(String name, Object value, boolean encodeSlashInPath)
				Create a new WebTarget instance by resolving a URI template with a given name in the URI of the current target instance using a supplied value.
				
			11. WebTarget	resolveTemplateFromEncoded(String name, Object value)
				Create a new WebTarget instance by resolving a URI template with a given name in the URI of the current target instance using a supplied encoded value.
				
			12. WebTarget	resolveTemplates(Map<String,Object> templateValues)
				Create a new WebTarget instance by resolving one or more URI templates in the URI of the current target instance using supplied name-value pairs.
				
			13. WebTarget	resolveTemplates(Map<String,Object> templateValues, boolean encodeSlashInPath)
				Create a new WebTarget instance by resolving one or more URI templates in the URI of the current target instance using supplied name-value pairs.
				
			14. WebTarget	resolveTemplatesFromEncoded(Map<String,Object> templateValues)
				Create a new WebTarget instance by resolving one or more URI templates in the URI of the current target instance using supplied name-encoded value pairs.
				
				
		Interface SyncInvoker
		---------------------
		
			Uniform interface for synchronous invocation of HTTP methods.
			
				Response	delete()
					Invoke HTTP DELETE method for the current request synchronously.
					
				<T> T	delete(Class<T> responseType)
					Invoke HTTP DELETE method for the current request synchronously.
					
				<T> T	delete(GenericType<T> responseType)
					Invoke HTTP DELETE method for the current request synchronously.
					
					ex: List<Message>
						delete(new GenericType<List<Message>>());
					
				Response	get()
					Invoke HTTP GET method for the current request synchronously.
					
				<T> T	get(Class<T> responseType)
					Invoke HTTP GET method for the current request synchronously.
					
				<T> T	get(GenericType<T> responseType)
					Invoke HTTP GET method for the current request synchronously.
					
					ex: List<Message>
						get(new GenericType<List<Message>>());
					
				Response	head()
					Invoke HTTP HEAD method for the current request synchronously.
					
				Response	method(String name)
					Invoke an arbitrary method for the current request synchronously.
					
				<T> T	method(String name, Class<T> responseType)
					Invoke an arbitrary method for the current request synchronously.
					
				Response	method(String name, Entity<?> entity)
					Invoke an arbitrary method for the current request synchronously.
					
				<T> T	method(String name, Entity<?> entity, Class<T> responseType)
					Invoke an arbitrary method for the current request synchronously.
					
				<T> T	method(String name, Entity<?> entity, GenericType<T> responseType)
					Invoke an arbitrary method for the current request synchronously.
					
				<T> T	method(String name, GenericType<T> responseType)
				Invoke an arbitrary method for the current request synchronously.
				
				Response	options()
					Invoke HTTP OPTIONS method for the current request synchronously.
					
				<T> T	options(Class<T> responseType)
					Invoke HTTP OPTIONS method for the current request synchronously.
					
				<T> T	options(GenericType<T> responseType)
					Invoke HTTP OPTIONS method for the current request synchronously.
					
				Response	post(Entity<?> entity)
					Invoke HTTP POST method for the current request synchronously.
					
				<T> T	post(Entity<?> entity, Class<T> responseType)
					Invoke HTTP POST method for the current request synchronously.
					
				<T> T	post(Entity<?> entity, GenericType<T> responseType)
					Invoke HTTP POST method for the current request synchronously.
					
				Response	put(Entity<?> entity)
					Invoke HTTP PUT method for the current request synchronously.
					
				<T> T	put(Entity<?> entity, Class<T> responseType)
					Invoke HTTP PUT method for the current request synchronously.
					
				<T> T	put(Entity<?> entity, GenericType<T> responseType)
					Invoke HTTP PUT method for the current request synchronously.
					
				Response	trace()
					Invoke HTTP TRACE method for the current request synchronously.
					
				<T> T	trace(Class<T> responseType)
					Invoke HTTP TRACE method for the current request synchronously.
					
				<T> T	trace(GenericType<T> responseType)
				Invoke HTTP TRACE method for the current request synchronously.
				
		public static interface Invocation.Builder extends SyncInvoker
		--------------------------------------------------------------
		
		The builder, obtained via a call to one of the request(...) methods on a resource target, 
			provides methods for preparing a client request invocation, basically everything u need to build up ur request.
			
		Builder builds up request, it has methods 
		
			Invocation.Builder	accept(MediaType... mediaTypes)
				Add the accepted response media types.
				
			Invocation.Builder	accept(String... mediaTypes)
				Add the accepted response media types.
				
			Invocation.Builder	acceptEncoding(String... encodings)
				Add acceptable encodings.
				
			Invocation.Builder	acceptLanguage(Locale... locales)
				Add acceptable languages.
				
			Invocation.Builder	acceptLanguage(String... locales)
				Add acceptable languages.
				
			AsyncInvoker	async()
				Access the asynchronous uniform request invocation interface to asynchronously invoke the built request.
				
			Invocation	build(String method)
				Build a request invocation using an arbitrary request method name.
				
			Invocation	build(String method, Entity<?> entity)
				Build a request invocation using an arbitrary request method name and request entity.
				
			Invocation	buildDelete()
				Build a DELETE request invocation.
				
			Invocation	buildGet()
				Build a GET request invocation.
				
			Invocation	buildPost(Entity<?> entity)
				Build a POST request invocation.
				
			Invocation	buildPut(Entity<?> entity)
				Build a PUT request invocation.
				
			Invocation.Builder	cacheControl(CacheControl cacheControl)
				Set the cache control data of the message.
				
			Invocation.Builder	cookie(Cookie cookie)
				Add a cookie to be set.
				
			Invocation.Builder	cookie(String name, String value)
				Add a cookie to be set.
				
			Invocation.Builder	header(String name, Object value)
				Add an arbitrary header.
				
			Invocation.Builder	headers(MultivaluedMap<String,Object> headers)
				Replaces all existing headers with the newly supplied headers.
				
			Invocation.Builder	property(String name, Object value)
				Set a new property in the context of a request represented by this invocation builder.
				
		
		public interface Invocation
		---------------------------
		
		A client request invocation. An invocation is a request that has been prepared and is ready for execution. 
			Invocations provide a generic (command) interface that enables a separation of concerns between the creator and the submitter. 
			In particular, the submitter does not need to know how the invocation was prepared, 
				but only how it should be executed (synchronously or asynchronously) and when.
					
			1. Response	invoke()
				Synchronously invoke the request and receive a response back.
				
			2. <T> T	invoke(Class<T> responseType)
				Synchronously invoke the request and receive a response of the specified type back.
				
			3. <T> T	invoke(GenericType<T> responseType)
				Synchronously invoke the request and receive a response of the specified generic type back.
				
			4. Invocation	property(String name, Object value)
				Set a new property in the context of a request represented by this invocation.
				
			5. Future<Response>	submit()
				Submit the request for an asynchronous invocation and receive a future response back.
				
			6. <T> Future<T>	submit(Class<T> responseType)
				Submit the request for an asynchronous invocation and receive a future response of the specified type back.
				
			7. <T> Future<T>	submit(GenericType<T> responseType)
				Submit the request for an asynchronous invocation and receive a future response of the specified generic type back.
				
			8. <T> Future<T>	submit(InvocationCallback<T> callback)
				Submit the request for an asynchronous invocation and register an InvocationCallback to process the future result of the invocation.
							
			
	Best Practices
	--------------
			
	Instead of having the url repeating in every target we can have it separated out as baseTarget and extend it.
	
		WebTarget baseTarget = client.target("http:localhost:8080/webapi/");
			
		WebTarget messages = baseTarget.path("messages");
		
		WebTarget singleMessageTarget = messages.path("{messageId}");
		
		Message messsage = singleMessageTarget.resolveTemplate("messageId", 1)
												.request(MediaType.APPLICATION_JSON)
												.get(Message.class);
		
		
	--------------------------------------------------------------------------------------------------------
	
	Sending Message body in request
	-------------------------------
	
		When request method is POST, then we use Entity wrapper to wrap our CustomType
		The conversion between our CustomType that we want to send in the body is done by Wrapper
		It supports the following methods
		
			static <T> Entity<T>	entity(T entity, MediaType mediaType)
				Create an entity using a supplied content media type.
				
			static <T> Entity<T>	entity(T entity, MediaType mediaType, Annotation[] annotations)
				Create an entity using a supplied content media type.
				
			static <T> Entity<T>	entity(T entity, String mediaType)
				Create an entity using a supplied content media type.
				
			static <T> Entity<T>	entity(T entity, Variant variant)
				Create an entity using a supplied content media type.
				
			static <T> Entity<T>	entity(T entity, Variant variant, Annotation[] annotations)
				Create an entity using a supplied content media type.
				
			static Entity<Form>	form(Form form)
				Create an "application/x-www-form-urlencoded" form entity.
				
			static Entity<Form>	form(MultivaluedMap<String,String> formData)
				Create an "application/x-www-form-urlencoded" form entity.
				
			Annotation[] 	getAnnotations()
				Get the entity annotations.
				
			String	getEncoding()
				Get entity encoding.
				
			T 	getEntity()
				Get entity data.
				
			Locale	getLanguage()
				Get entity language.
				
			MediaType	getMediaType()
				Get entity media type.
				
			Variant	getVariant()
				Get entity variant information.
				
			static <T> Entity<T>	html(T entity)
				Create a "text/html" entity.
				
			static <T> Entity<T>	json(T entity)
				Create an "application/json" entity.
				
			static <T> Entity<T>	text(T entity)
				Create a "text/plain" entity.
				
			static <T> Entity<T>	xhtml(T entity)
				Create an "application/xhtml+xml" entity.
				
			static <T> Entity<T>	xml(T entity)
				Create an "application/xml" entity.
		
		
	Create a POST request
	---------------------
	
		Response postResponse = messageTarget.request()
											.post(Entity.json(newMessage))
		
		sop(postResponse);	//status=201, reason=Created
		
		Message createdMessage= postResponse.readEntity(Message.class);
		
	Handling GenericType in the client
	----------------------------------
	Generic types like returning a List
		ex: List<Message>
				get(new GenericType<List<Message>>());
		
	----------------------------------------------------------------------------------------------------------------
			
	Implementing Filters
	--------------------
		
		Contains cross cutting concerns so that we don't need to implement them in each and every request.
		Filter is invoked no matter the request is successful or error.
		Any class implementing the below filters need to be annotated with @Provider.
		
		
		There are 2 types of Filters
		
			1. ContainerRequestFilter	- 	called before the request in invoked
			
				Method:	filter(ContainerRequestContext reqContext)
			
			2. ContainerResponseFilter	- 	called after the response is prepared
				
				Method: filter(ContainerRequestContext reqContext, ContainerResponseContext resContext)
		
		
		
	---------------------------------------------------------------------------------------------------------------
	
	Client session based Authentication
	-----------------------------------
								
								
					Classic session based Authentication
					------------------------------------
								
								username/password
			Client	------------------------------------------>	Server
									request
			
							session token as a cookie
			Client	<-----------------------------------------	Server
									response
		   (cookie)
								session token
			Client	------------------------------------------>	Server
									request

								session token
			Client	------------------------------------------>	Server
									request
		
		
	Session based authentication is a problem with REST API's since it is Stateless.

	So everytime request is made authentication is sent in every request which is called Basic auth.
	
								username/password
			Client	------------------------------------------>	Server
									request
		
	Basic auth - Client side
	------------------------
									Base64 encoding
			username:password	----------------------->	dXcvBnMweRTsgnHmoP3N9j=
		 _________________________________________________________
		|														  |
		| 	Header: Authorization:	Basic dXcvBnMweRTsgnHmoP3N9j= |
		|---------------------------------------------------------|
		|	Body  : .............								  |
		|_________________________________________________________|
		
		
		
	Encoding is not providing security. Anybody will be able to decode Base64. But the intent of encoding is to encode 
		non-HTTP compatible characters that may be in the username and password into those that are HTTP-compatible.
		
	So inorder to ensure security we need to use HTTPS.
		
		
	Advantages:
	----------
	
		1. Simple
		2. Stateless server
		3. Supported by all browsers
		
	Disadvantages
	-------------
		1. Requires Https
		2. Subject replay attacks
		3. Logout is tricky
		
		
	There are better solution to encrypt the username/password like 
	
		1. Digest access, 
		2. Asymmetric cryptography, 
		3. OAuth, 
		4. JWT(Json web tokens)
		
		
	Implementing Basic Auth in our Rest API
	---------------------------------------
	
		Since auth info is sent as a key "Authorization", we can get it's value from the header
			in our concrete class implementing ContainerRequestFilter.
			
			List<String> authHeader= requestContext.getHeader().get("Authorization")
			
			String authToken= authHeader.get(0);	//returns Basic dXcvBnMweRTsgnHmoP3N9j=
			
			authToken = authToken.replaceFirst("Basic ", "");
			
			String decodedString= Base64.decodeAsString(authToken);	// returns username:password
			
			StringTokenizer tokens = new StringTokenizer(decodedString, ":");
			
			String userName= tokens.nextToken();
			String password= tokens.nextToken();
		
			//check creadentials are valid
				//doSomething
			//else
				Response unauthorizedResponse= Response.status(Response.status.UNAUTHORIZED)
														.entity("You don't have access to the resource")
														.build();
														
				requestContext.abortWith(unauthorizedResponse);
		
		This filter is going to be executed for every request, we can also make it work for certains URI's
			by getting the uriPath from requestContext.
	

	Interceptors
	------------
	
		1. Model similar to Filters
		2. Used to manipulate entities (input and output streams) : MessageBody
		
		2 Kinds
			1. ReaderInterceptor
			2. WriterInterceptor


	Interceptors vs Filters
	-----------------------
	
		1. Used to manipulate message body				1. Used to manipulate request and response params
															headers, uri's etc
		
		2. 2 Kinds										2. 2 Kinds
			1. ReaderInterceptor							1. ContainerRequestFilter
			2. WriterInterceptor							2. ContainerResponseFilter

		Example: Encoding a response Entity				Example: Logging, Security etc.



	Filters and Interceptors can be implemented on the client side as well.
	
	It works the same way as it works on the server side.
		
		Filters
			1. ClientRequestFilter
			2. ClientResponseFilter
		
		Interceptor								MessageBody
			1. ReaderInterceptor					1. MessageBodyReader
			2. WriterInterceptor					2. MessageBodyWriter


	Order of execution
	------------------
		Client side (before sending out request)
			1. ClientRequestFilter
			2. WriterInterceptor
			3. MessageBodyWriter
		
		Server side (before processing request)
			4. ContainerRequestFilter
			5. ReaderInterceptor
			6. MessageBodyReader
			
		Server side (before sending out response)
			7. ContainerResponseFilter
			8. WriterInterceptor
			9. MessageBodyWriter
		
		Client side (before receiving response)
			10. ContainerRespnseFilter
			11. ReaderInterceptor
			12. MessageBodyReader
			
						1. ContainerRequestFilter									
						2. WriterInteceptor										
						3. MessageBodyWriter										
																				4. ContainerRequestFilter
																				5. ReaderInterceptor
																				6. MessageBodyReader
		Client 			------------------------------------------------------------------------------>			Server
																				7. ContainerResponseFilter
																				8. WriterInterceptor
																				9. MessageBodyWriter
						10. ContainerResponseFilter
						11. ReaderInterceptor
						12. MessageBodyReader










	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		